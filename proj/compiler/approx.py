
"""
Our approximating compiler.

This takes as input code written in Python/C-esque syntax, outputs C++ code, and compiles and runs that.

See test applications for usage.
"""

import os
import copy
import inspect
import re
import traceback
import sys; sys.path += ['../solver']
import parse_args
import sha
import math
import numpy
import shutil
import ntpath
import time
import random
import re
import platform

_max = max
_min = min
_abs = abs

DEFAULT_INT_BITS   = 32
DEFAULT_FLOAT_BITS = 32

add_runner = True
default_num_iters = 3                 # Should be at least 2 to have accurate timing (first iter loads, allocates)

optimize_channels    = True           # Optimize by only computing the first channel in e.g. weightings or samples

show_ids = False
debug = False
bounds_check          = False           # Generated code checks Array bounds during accesses
debug_save            = False           # Save some debugging images
profile_time          = False           # Print running times for various functions
prevent_underflow     = True            # Prevent underflow in interpolation by copying nearest neighbor samples if needed
min_density           = False           # Prevent too small of sampling density by putting down a coarse grid sampling
use_sigma_max         = True            # Use a maximum sigma for spatially varying Gaussian to prevent color 'leaking'

min_density_spacing = 10
sigma_max_mul       = 1.5

filter_iir_fast       = True           # Run filter_iir() using the fast implementation in array.h
rescale_fast          = True           # Rescale using a fast implementation based on histograms
vectorize_reconstruct = True           # Do faster reconstruction by vectorizing

importance_method = 'gaussian'        # One of 'box' (box blur), 'gaussian' (Gaussian blur)
dither_method = 'ost'                 # One of 'floyd' (Floyd-Steinberg), 'ost' (Ostromoukhov 2001)

synthetic_importance  = False          # Debugging -- generate synthetic importance map (an x ramp function)
simplify_congruence   = True           # Use z3 module to simplify interpolations using congruence proofs

if simplify_congruence:
    import congruence

numpy_int_types = (numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64)
numpy_float_types = (numpy.float32, numpy.float64)
numpy_types = numpy_int_types + numpy_float_types

indent_str = ' '*2

# -fno-tree-pre is necessary to work around a gcc 4.8.1 bug (for img_abstraction.py in parallel mode)
#cpp_compiler = 'g++ -o %s -O3 -fopenmp -funroll-loops -fmax-errors=3 -std=c++0x -fabi-version=6 -DBUILD_DEBUG=0 -I /opt/X11/include %s ../solver/array.cpp ../solver/pfm.cpp ../solver/timer.cpp ../solver/util.cpp -L /opt/X11/lib -lpthread -lpng -ldl -fno-tree-pre'
flags = '-O3 -fopenmp -funroll-loops -fmax-errors=3 -std=c++0x -fabi-version=6 -DBUILD_DEBUG=0 -I /home/pn2yr/include -I /opt/X11/include' if ('lc5' in platform.node()  or 'fir' in platform.node()) else '-O3 -fopenmp -funroll-loops -fmax-errors=3 -std=c++0x -fabi-version=6 -DBUILD_DEBUG=0 -I /opt/X11/include'

if bounds_check:
    flags = flags.replace('-O3', '-g').replace('-DBUILD_DEBUG=0', '-DBUILD_DEBUG=1')

solver_files = ['../solver/array.cpp', '../solver/pfm.cpp', '../solver/timer.cpp', '../solver/util.cpp']
object_files = map(lambda x: x.replace('../solver/','').replace('.cpp','.o'), solver_files)
object_files_string = ' '.join(object_files)
solver_compilation_statements = ''.join([ 'echo "if test '+f[0]+' -nt '+f[1]+'; then g++ -c '+flags+' '+f[0]+' -o '+f[1]+'; fi; " | bash ; ' for f in zip(solver_files,object_files) ])
cpp_compiler = solver_compilation_statements + 'g++ '+object_files_string+' -o %s '+flags+' %s       -L /opt/X11/lib -lpthread -lpng -ldl -fno-tree-pre'

header = r"""
/* Generated by approx.py, do not hand edit */

#include "../solver/array.h"
#include "../solver/timer.h"
#include <stdlib.h>
#include <cmath>
#include <algorithm>

using namespace std;
"""

runner = r"""

int main(int argc, char *argv[]) {
  argc--; argv++;
  if (argc < 1+%(n_in)d) {
    fprintf(stderr, "program ");
    for (int i = 0; i < %(n_in)d; i++) {
      fprintf(stderr, "in%%d.png ", i);
    }
    fprintf(stderr, "out.png|.pfm\n");
    exit(1);
  }
  char *out_filename = argv[%(n_in)d];

  vector<%(input_type)s> in_orig_L(%(n_in)d);
  vector<%(input_type)s> in_L(%(n_in)d);
  for (int i = 0; i < %(n_in)d; i++) {
    auto in_orig_scalar(load_color_image<%(in_scalar_type)s>(argv[i]));
    copy_array(in_orig_scalar, in_orig_L[i]);
  }  
  
  %(output_type)s out;
  
  for (int iter = 0; iter < %(num_iters)d; iter++) {
    for (int i = 0; i < %(n_in)d; i++) {
      in_L[i] = in_orig_L[i];
    }
    srand(0);
    double T0 = wall_time();
    %(main_func)s(%(in_args)s, out);
    double T1 = wall_time();
    printf("Total time: %%f\n", T1-T0);
  }
  
  Array<%(out_scalar_type)s> out_scalar;
  copy_array(out, out_scalar);
  save_color_image(out_scalar, out_filename);
  return 0;
}
"""

main_func = 'main_func'

# ------------------------------------------------------------------------------------
# AST and C++ code generator
# ------------------------------------------------------------------------------------

def get_profile_time(kw={}):
    return kw.get('profile_time', profile_time)
    
def indent(s, n=1):
    indent_n = indent_str * n
    L = s.split('\n')
    return '\n'.join(indent_n + x for x in L)

do_add_exprs = True

def get_add_exprs():
    return do_add_exprs
    
def set_add_exprs(add):
    global do_add_exprs
    do_add_exprs = add
    
class Node(object):
    def __init__(self, children=[]):
        if debug:
            self.block_trace()
        self.children = list(children)
        
    def block_trace(self):
        if len(block_stack):
            print '-'*72
            print 'Debug info: Partially built program (%s instance)' % (self.__class__.__name__)
            print '-'*72
            traceback.print_stack()
            print
            print block_stack[0]
            print

    def check(self):
        pass
    
    def str(self, is_statement=False):
        self.check()
        #print 'str(), self is', id(self)
        return self.__class__.__name__ + '()'
        
    def repr(self, seen):
        #print '__repr__ of ', self.__class__.__name__, 'self is', id(self), 'children are', [id(x) for x in self.children]
        ans = self.str()
        if show_ids:
            ans += ' [%d]' % id(self)
        if self not in seen:
            seen.add(self)
            for x in self.children:
                if x is not None:
                    ans += '\n' + indent(x.repr(seen))
                else:
                    ans += '\nNone'
        return ans
    
    def __repr__(self):
        return self.repr(set())
        
    def codegen(self, **kw):
        raise NotImplementedError
    
    def __del__(self):                      # Hack to add expressions to the current block
        try:
            if isinstance(self, Const):
                return
            if len(block_stack) > 1 and do_add_exprs and (not hasattr(self, 'add') or self.add):
                if debug:
                    print '====> Adding in del', self
                get_block().children.append(self)
                if debug:
                    self.block_trace()
        except TypeError:
            pass

def system(s):
    print s
    return os.system(s)

def declare_copy_array(headers, source_type, dest_type):
#    print 'source_type', source_type
#    print 'dest_type  ', dest_type
    #assert dest_type.vectorize is not None or source_type.vectorize is not None
    dest_atom = dest_type.atom()
    source_atom = source_type.atom()
    dest_s = dest_type.codegen()
    source_s = source_type.codegen()
    
    before = ''
    after = ''
    varL = []
    source_varL = []
    fullL = []
    #ans_sizes = []
    indent_count = 1
    for dim in range(dest_type.dims):
        if dest_type.vectorize != dim:
            var = '_x%d' % dim
            varL.append(var)
            if source_type.vectorize != dim:
                source_varL.append(var)
            size = dest_type.get_size('dest', dim, False)
            #ans_sizes.append(size)
            before += indent('for (int %s = 0; %s < %s; %s++) {\n' % (var, var, size, var), indent_count).rstrip(' ')
            after = indent('}\n', indent_count).rstrip(' ') + after
            indent_count += 1
            fullL.append(var)
        else:
            fullL.append('%d')
    full_str = ', '.join(fullL)
    #ans_sizes = ', '.join(ans_sizes)
    
    if dest_type.vectorize is not None:
        mid = 'dest.get_nearest(%s) = %s {' % (', '.join(varL), dest_atom)
        midL = []
        for i in range(dest_type.atom_size()):
            midL.append('%d < source.sizes[%d] ? source(%s): 0' % (i, dest_type.vectorize, full_str % i))
        mid += ', '.join(midL) + '};'
    elif source_type.vectorize is not None:
        source_part = 'source(%s)[%s];' % (', '.join(source_varL), varL[source_type.vectorize])
        dest_part = 'dest.get_nearest(%s)' % full_str
        mid = '%s = %s;' % (dest_part, source_part)
#        mid = 'dest(%s) = source(%s)[%s];' % (full_str, ', '.join(source_varL), varL[source_type.vectorize])
    else:
        # TODO: Would be faster to add correct steps for these loops
        mid = 'dest.get_nearest(%s) = source(%s);' % (', '.join(varL), ', '.join(varL))
        
    s = before + indent(mid, indent_count) + '\n' + after
    s = """
void copy_array(const %(source_s)s &source, %(dest_s)s &dest) {
  dest.resize(source.sizes);
%(s)s
}
""" % locals()
#  printf("source.sizes: %%s\\n", vector_to_str_int(source.sizes).c_str());
#  printf("dest.sizes: %%s\\n", vector_to_str_int(dest.sizes).c_str());
        
    if s not in headers:
        headers.append(s)    

class Statement(Node):
    def __init__(self, children=[], add=True):
        self.add = add
        Node.__init__(self, children)
        if add and not isinstance(self, Program):
            get_block().children.append(self)
            if debug:
                print '====> Debug: Adding %s instance' % self.__class__.__name__
                self.block_trace()

class Block(Statement):
    def remove(self):
        b = get_block()
        for (i, child) in enumerate(b.children):
            if child is self:
                del b.children[i]
                return
        raise ValueError('self not found in children of get_block()')
        
    def __enter__(self):
        push_block(self)
        return self
        
    def __exit__(self, *args):
        pop_block()

    def codegen(self, is_statement=False, **kw):
        return self.children_codegen(kw)
        
    def children_codegen(self, kw, start=0):
#        for child in self.children[start:]:
#            print child
#            child.codegen(True, **kw)
        return '\n'.join(child.codegen(True, **kw) for child in self.children[start:])

def remove_redundant_lines(s):
    L = s.split('\n')
    i = 0
    while i < len(L):
        current = L[i].strip()
        if i + 1 < len(L) and current.endswith('clear();') and L[i+1].strip() == current:
            del L[i]
        else:
            i += 1
    return '\n'.join(L)

class CompileError(Exception):
    pass

class Program(Block):
    def __init__(self, *args):
        self.header_funcs = []        
        Block.__init__(self, *args)
        
    def check(self):
        for x in self.children:
            assert isinstance(x, Statement)

    def codegen(self, is_statement=False, headers=None, **kw):
        with self:
            reset_debug_index()
            if headers is None:
                headers = []
            self.check()
            ans = '\n'.join([child.codegen(True, headers=headers, **kw) for child in self.children])
            if add_runner:
                source_type = None
                dest_type = Float()
                found = False
                
                copy_types = set()
                
                for func in self.children:
                    if isinstance(func, Function) and func.name == main_func:
                        #print 'Compiler: func is main_func'
                        n_in = len(func.arguments())-1
                        in_args = ', '.join('in_L[%d]'%j for j in range(n_in))
                        n_args = sum([isinstance(func.children[i], Argument) for i in range(len(func.children))])
                        for i in range(len(func.children)):
                            #print 'Compiler: func child %d' % i
                            if len(func.children) and isinstance(func.children[i], Argument):
                                #print 'Compiler: func child %d is Argument, n_args=%d' % (i, n_args)
                                found = True
                                source_type = copy.copy(func.children[i].type)
                                source_type.vectorize = None
                                source_type.set_spacing()
                                dest_type = func.children[i].type
                                if i == 0:
                                    input_type = dest_type.codegen()
                                    in_scalar_type = dest_type.scalar()
                                elif i == n_args-1:
                                    output_type = dest_type.codegen()
                                    out_scalar_type = dest_type.scalar()
                                    #print 'Compiler: received output_type=%s' % output_type
    #                            found = True
                
                                if source_type.codegen() != dest_type.codegen():
                                    pair = (source_type.codegen(), dest_type.codegen())
                                    if not pair in copy_types:
                                        copy_types.add(pair)
                                        declare_copy_array(headers, source_type, dest_type)
                                        declare_copy_array(headers, dest_type, source_type)
                    
                #array_type = dest_type.codegen() #'Array<%s>' % dest_type.atom()
                #print 'dest_type:', dest_type
                #print 'dest_type.codegen():', array_type
                #raise ValueError
                #print 'Compiler: output_type:', output_type
                if not found:
                    raise ValueError('no main_func')
                atom_type = dest_type.atom()
                num_iters = kw.get('num_iters', default_num_iters)
                ans += runner % {'in_args': in_args, 'n_in': n_in, 'input_type': input_type, 'output_type': output_type, 'atom_type': atom_type, 'in_scalar_type': in_scalar_type, 'out_scalar_type': out_scalar_type, 'main_func': main_func, 'num_iters': num_iters}
            ans = '\n'.join([transform_loop_missing(child).codegen(True, headers=headers, **kw) for child in self.header_funcs]) + '\n' + ans
            ans = header + '\n' + '\n'.join(headers) + '\n' + ans
            
            return remove_redundant_lines(ans)
    
    def compile_to_file(self, filename, **kw):
        filename_cpp = filename + '.cpp'
        filename_bin = filename
        print 'Compiling %s => %s' % (filename_cpp, filename_bin)
        s = self.codegen(**kw)
        print '  (%d bytes)' % len(s)
        with open(filename_cpp, 'wt') as f:
            f.write(s)
        cpp_compiler_s = cpp_compiler
        if kw.get('debug', False):
            cpp_compiler_s = cpp_compiler_s.replace('-O3', '-g')
            cpp_compiler_s = cpp_compiler_s.replace('-DBUILD_DEBUG=0', '-DBUILD_DEBUG=1')
        result = system(cpp_compiler_s % (filename_bin, filename_cpp))
        print 'Result:', result
        if result:
            raise CompileError
        
block_stack = []

def get_block():
    return block_stack[-1]

def push_block(b):
    block_stack.append(b)

def pop_block():
    block_stack.pop()
    
class ForVars(Node):
    def __init__(self, vars):
        Node.__init__(self, vars)

SAMPLE_GRID       = 0
SAMPLE_IMPORTANCE = 1
SAMPLE_ADAPTIVE   = 2

RECONSTRUCT_COMPUTE = 0
RECONSTRUCT_STORE   = 1

DEFAULT_IMPORTANCE_FRAC = 0.3
DEFAULT_IMPORTANCE_SIGMA = 1.0/64 #1.0/64
DEFAULT_ADAPTIVE_GRID_SIZE = 2

DEFAULT_RECONSTRUCT_T = 0.0
DEFAULT_RECONSTRUCT_SIGMA = 0.5

#def default_kernel():
#    return gaussian_kernel_macro(0.5)
#    return [0.42649, 0.34822, 0.0, 0.0, 0.0]        # From test_iir.py, gamma=3
#    return [0.87895, 0.50357, 0.0, 0.0, 0.0]        # gamma=2
#    return [0.62231, 0.73594, 0.0, 0.0, 0.0]        # gamma=1
    
class Missing(Node):            # Similar to None, used to identify a node that has no value
    def codegen(self, **kw):
        return ''

def reconstruct_none(foreach, img, Isample, refArray, spatially_varying=False):
    pass

def reconstruct_nearest(foreach, img, Isample, refArray):
    copy_nearest(img, Isample)
    if debug_save:
        debug_image(Isample, 'Isample_after_nearest.pfm', 1)

def reconstruct_gaussian(foreach, img, Isample, refArray, spatially_varying=False):
    x = Var(prefix='_x_')
    y = Var(prefix='_y_')
    if profile_time:
        T0 = Var(wall_time())

    if foreach.t[0] != 0.0:
        with ForEach((y, x), Isample, prefix='__reconstruct_gaussian_tnonzero_'):
            Isample[y, x] = ((1-foreach.t[0])*Isample[y,x] if foreach.t[0] != 1.0 else 0.0) + foreach.t[0]
            img[y,x]      = ((1-foreach.t[0])*    img[y,x] if foreach.t[0] != 1.0 else 0.0) + foreach.t[0]*refArray[y,x]

    vec_mode = Var(Int(), 0)
    
    if spatially_varying:
        Isigma = foreach.Isigma()
        if debug_save:
            debug_image(Isigma, 'Isigma.pfm')
            debug_image(img, 'img_before_reconstruct.pfm')
            debug_image(Isample, 'Isample_before_reconstruct.pfm', 1)
        gaussian_blur_sat(img,     img,     Isigma, channels=foreach.channels)
        gaussian_blur_sat(Isample, Isample, Isigma, channels=1 if optimize_channels else foreach.channels)
#        gaussian_blur_sat(img,     img,     Isigma)
#        gaussian_blur_sat(Isample, Isample, Isigma)
        if debug_save:
            debug_image(img, 'img_filter_before_copy_nearest.pfm')
            debug_image(Isample, 'Isample_filter_before_copy_nearest.pfm', 1)
        copy_nearest(img, Isample, 1)
    else:
        if img.type.dims in [3, 4]:
            sigma0 = foreach.sigma[0]
            if not foreach.is_grid_approx():
                sigma0 /= math.sqrt(foreach.frac[0])
            else:
                #print 'gmean', numpy.exp(numpy.mean(numpy.log(foreach.spacing[0])))
                sigma0 *= numpy.exp(numpy.mean(numpy.log(foreach.spacing[0])))
            sigma = gaussian_kernel_macro(sigma0)
            #print 'sigma actual', sigma0, foreach.frac[0]

            if img.type.dims == 3 and vectorize_reconstruct:
                Ivec_type = copy.deepcopy(img.type)
                Ivec_type.vectorize = 2
                Ivec_sizes = list(Ivec_type.sizes)
                Ivec_sizes[2] = 4
                Ivec_type.sizes = tuple(Ivec_sizes)
                with If(img.channels()==3):
                    Ivec = Var(Ivec_type, img.sizes())
                    with ForEach((y, x), Ivec):
                        Ivec[y,x,0] = img[y,x,0]
                        Ivec[y,x,1] = img[y,x,1]
                        Ivec[y,x,2] = img[y,x,2]
                        Ivec[y,x,3] = Isample[y,x,0]
                    filter_iir(Ivec, sigma, 0.0)
                    with ForEach((y, x), img, prefix='__reconstruct_gaussian_div_3d_vec_'):
                        for channel in range(foreach.channels):
                            Assign(img[y,x,channel], Ivec[y,x,channel]/Ivec[y,x,3])
                            if prevent_underflow:
                                Assign(Isample[y,x,0], Ivec[y,x,3])
                    Assign(vec_mode, 1)

            with If(Not(vec_mode)):
                filter_iir(img, sigma, 0.0)
                filter_iir(Isample, sigma, 0.0, channels=1 if optimize_channels else None)

            if prevent_underflow:
                copy_nearest(img, Isample, 1)
        else:
            raise ValueError('number of dims not implemented: %d' % img.type.dims)
 
    if debug_save:
        debug_image(img, 'img_filter.pfm')
        debug_image(Isample, 'Isample_filter.pfm', 1)
    if img.type.dims == 3:
        with If(Not(vec_mode)):
            with ForEach((y, x), img, prefix='__reconstruct_gaussian_div_3d_'):
         #       img[y,x] /= Isample[y,x]
                for channel in range(foreach.channels):
                    Assign(img[y,x,channel], img[y,x,channel]/Isample[y,x,0 if optimize_channels else channel])
    elif img.type.dims == 4:
        with If(Not(vec_mode)):
            idx = Var(prefix='_idx_')
            with ForEach((idx, y, x), img, prefix='__reconstruct_gaussian_div_4d_'):
                for channel in range(foreach.channels):
                    Assign(img[idx,y,x,channel], img[idx,y,x,channel]/Isample[idx,y,x,0 if optimize_channels else channel])
    else:
        raise ValueError('number of dims not implemented: %d' % img.type.dims)
    
    if profile_time:
        printf('reconstruct_gaussian: %f secs\n', wall_time()-T0)
        
def reconstruct_gaussian_sv(*args):
    """Reconstruct with spatially varying Gaussian."""
    reconstruct_gaussian(*args, spatially_varying=True)

def reconstruct_linear():
    """Reconstruct with linear/bilinear/trilinear filtering."""
    assert False, 'reconstruct_linear() should not be called directly (it is valid only for .sample_grid() approximation)'

FOREACH_DO_RECONSTRUCT_CHILD = 7
FOREACH_DO_SAMPLES = 6

# Special sampling flags for adaptive mode
ADAPTIVE_FINE_SAMPLE              = 1.0
ADAPTIVE_COARSE_CONVERTED_TO_FINE = 1 - 1e-7
ADAPTIVE_COARSE_SAMPLE            = 1 - 2e-7

class ForEach(Block):
    def __init__(self, vars, outputArray, refArray=None, start=None, stop=None, step=None, parallel=None, parallel_options='', identical_channels=False, importance_func=None, rescale=True, reconstruct_func=reconstruct_gaussian, do_samples=True, do_reconstruct=True, name=None, tune_reconstruct=True, dither=True, allow_importance_args_change=True, importance_args=None, prefix=''):
        outputArray = as_expr(outputArray)
        L = [ForVars(vars), outputArray] + [as_expr_missing(x) for x in [refArray, start, stop, step, do_samples, do_reconstruct]]
        self.arg_count = len(L)
        self.do_continue = True
        if name is None:
            name = prefix + make_varname()
        self.name = name
        self.tune_reconstruct = tune_reconstruct
        
        try:
            self.total_channels = outputArray.channels_const()
        except ValueError:
            self.total_channels = 1
        self.channels = self.total_channels          # Sampled channels
        self.dims = outputArray.dims_const()
        
        self.default_mode()
        
        self.spacing = [tuple([1 for i in range(len(vars))]) for j in range(self.total_channels)]
        self.frac = [DEFAULT_IMPORTANCE_FRAC for j in range(self.total_channels)]
        if importance_args is None:
            self.importance_args = ([DEFAULT_IMPORTANCE_SIGMA for j in range(self.total_channels)],)
        else:
            self.importance_args = tuple([[importance_args[i] for j in range(self.total_channels)]
                                         for i in range(len(importance_args))])
        
        self.t = [DEFAULT_RECONSTRUCT_T for j in range(self.total_channels)]
        self.sigma = [DEFAULT_RECONSTRUCT_SIGMA for j in range(self.total_channels)]
        
        #self.importance_func = default_importance(outputArray.type)
        #self.dither_func = floyd(outputArray.type)
        self.parallel = parallel
        self.parallel_options = parallel_options
        
        self.identical_channels = identical_channels
        self.importance_func = importance_func
        self.rescale = rescale
        self.reconstruct_func = reconstruct_func
        self.dither = dither
        
        self.contiguous_frac = 1.0
        self.random_p = 1.0        
        self.adaptive_grid_size = DEFAULT_ADAPTIVE_GRID_SIZE

        self.allow_importance_args_change = allow_importance_args_change
        
        Block.__init__(self, L)
    
    def Isample_info(self, is_statement):
        refArray = self.children[2]

        Itype = copy.deepcopy(refArray.type)
        Itype.basetype = 'Float'
        Itype.bits = 32

        sizes = refArray.sizes() if is_statement else None
        return (Itype, sizes)
        
    def Isample(self, is_statement=False):
        (Itype, sizes) = self.Isample_info(is_statement)
        return Var(Itype, sizes, name='_Isample%s' % self.name, is_statement=is_statement, add=is_statement)

    def Iadaptive(self, is_statement=False):
        (Itype, sizes) = self.Isample_info(is_statement)
        return Var(Itype, sizes, name='_Iadaptive%s' % self.name, is_statement=is_statement, add=is_statement)

    def Isigma(self, is_statement=False):
        (Itype, sizes) = self.Isample_info(is_statement)
        return Var(Itype, sizes, name='_Isigma%s' % self.name, is_statement=is_statement, add=is_statement)
        
    def has_identical_channels(self):
        def identical(Lv):
            return all(len(set(v)) == 1 for v in Lv)
        return self.identical_channels or identical((self.frac, self.t, self.sigma) + self.importance_args)
        
    def default_mode(self):
        self.sample_mode = [SAMPLE_GRID for i in range(self.total_channels)]
        self.reconstruct_mode = RECONSTRUCT_COMPUTE

    def is_grid_approx(self):
        return any([x != 1 for x in self.spacing[0]])

    def is_importance_approx(self):
        return any([x==SAMPLE_IMPORTANCE for x in self.sample_mode])

    def is_adaptive_approx(self):
        return any([x==SAMPLE_ADAPTIVE for x in self.sample_mode])

    def is_approx(self):
        self.make_consistent()
        if self.is_importance_approx():
            return True
        if self.is_adaptive_approx():
            return True
#        if self.get_output_array().type.has_spacing():
#            return True
        if self.is_grid_approx():
            return True
#        print self.spacing[0]
#        print self.get_output_array().type.spacing
#        if self.channels < self.total_channels:
#            return True
        return False
            
    def convert_spacing(self, spacing):
        nvars = len(self.children[0].children)
        assert len(spacing) >= nvars
        return spacing[:nvars]
        
    def get_output_array(self):
        return self.children[1]
    
    def do_reconstruct_const(self):
        do_reconstruct = self.children[FOREACH_DO_RECONSTRUCT_CHILD]
        if isinstance(do_reconstruct, Const):
            return do_reconstruct.value
        return True

    def make_consistent(self):
        self.t = [numpy.clip(x, 0.0, 1.0) for x in self.t]

        t = self.get_output_array().type
        if self.is_adaptive_approx() or self.is_importance_approx():
            self.reconstruct_mode = RECONSTRUCT_STORE
        
        #if t.has_spacing():               # If type has spacing then inherit from it and use compute reconstruct mode
        #    self.spacing = [self.convert_spacing(t.spacing) for j in range(self.total_channels)]
        #    self.default_mode()
        #else:
        if self.reconstruct_mode == RECONSTRUCT_STORE or (not self.do_reconstruct_const() and all([x == 1 for x in self.spacing[0]])):
            t.set_spacing()           # Set the type to have 1, 1, 1, ... as spacing. Handle the spacing ourselves.
        elif self.reconstruct_mode == RECONSTRUCT_COMPUTE:
            spacing = self.spacing[0] # Set type to have given spacing. Spacing handled by type
            t.set_spacing(spacing)
            t.is_nearest = self.reconstruct_func is reconstruct_nearest
        else:
            raise ValueError('unknown reconstruct_mode')
        
    def get_channels(self):
        channels = None
        if isinstance(channels, (int, long)):
            return [channels]
        elif channels is None:
            return [c for c in range(self.total_channels)]
        return channels
    
    def dimensions(self):
        vars = self.children[0].children
        return len(vars)

    def sample_grid(self, spacing, channels=None):
        self.channels = channels if channels is not None else self.total_channels
        assert self.dimensions() == len(spacing), 'expected spacing to be %d dimensions (for_loop.dimensions())' % self.dimensions()

        for c in self.get_channels():
            self.sample_mode[c] = SAMPLE_GRID
            self.spacing[c] = spacing
        self.make_consistent()
    
    def sample_importance(self, frac=DEFAULT_IMPORTANCE_FRAC, importance_args=(DEFAULT_IMPORTANCE_SIGMA,), channels=None):
        self.channels = channels if channels is not None else self.total_channels
        for c in self.get_channels():
            self.sample_mode[c] = SAMPLE_IMPORTANCE
            self.frac[c] = frac
            if self.allow_importance_args_change:
                if len(self.importance_args) != len(importance_args):
                    self.importance_args = ()
                    for i in range(len(importance_args)):
                        self.importance_args = self.importance_args + ([importance_args[j] for j in range(self.total_channels)],)
                for i in range(len(importance_args)):
                    self.importance_args[i][c] = importance_args[i]
#        raise ValueError(self.importance_args)
        self.make_consistent()

    def sample_adaptive(self, frac=DEFAULT_IMPORTANCE_FRAC, adaptive_grid_size=DEFAULT_ADAPTIVE_GRID_SIZE, channels=None):
        self.channels = channels if channels is not None else self.total_channels
        for c in self.get_channels():
            self.sample_mode[c] = SAMPLE_ADAPTIVE
            self.frac[c] = frac
            self.adaptive_grid_size = adaptive_grid_size
#        raise ValueError(self.importance_args)
        self.make_consistent()

    def reconstruct_compute(self, reconstruct_func=None):
        if reconstruct_func is not None and self.tune_reconstruct:
            self.reconstruct_func = reconstruct_func
        #for c in self.get_channels(channels):
        #    self.reconstruct_mode[c] = RECONSTRUCT_COMPUTE
        self.reconstruct_mode = RECONSTRUCT_COMPUTE
        self.make_consistent()
        
    def reconstruct_store(self, sigma=DEFAULT_RECONSTRUCT_SIGMA, reconstruct_func=None):
        if reconstruct_func is not None and self.tune_reconstruct:
            self.reconstruct_func = reconstruct_func
        self.reconstruct_mode = RECONSTRUCT_STORE
        for c in self.get_channels():
#            self.reconstruct_mode[c] = RECONSTRUCT_STORE
#            self.t[c] = t
            self.sigma[c] = sigma #copy.deepcopy(kernel)
        self.make_consistent()

    def set_do_reconstruct(self, value):
        self.children[FOREACH_DO_RECONSTRUCT_CHILD] = as_expr_missing(value)
    
    def set_do_samples(self, value):
        self.children[FOREACH_DO_SAMPLES] = as_expr_missing(value)
        
    def loop_perforation_mode(self):
        self.set_do_reconstruct(False)
        self.do_continue = False
        self.set_do_samples(False)

    def sample_step(self, step_mul):
        """Loop perforation optimization, disables reconstruction."""
        self.loop_perforation_mode()
        self.sample_grid([step_mul for i in range(self.dimensions())]); self.reconstruct_store()

    def sample_contiguous(self, frac):
        """Loop perforation optimization, disables reconstruction."""
        self.loop_perforation_mode()
        self.sample_grid([1 for i in range(self.dimensions())])
        self.contiguous_frac = float(frac)

    def sample_random(self, p):
        """Loop perforation optimization, disables reconstruction."""
        self.loop_perforation_mode()
        self.sample_grid([1 for i in range(self.dimensions())])
        self.random_p = float(p)

    def check(self):
        assert len(self.children) >= self.arg_count

    def is_spatially_varying(self):
        return self.reconstruct_func is reconstruct_gaussian_sv
    
    def arg_image(self):
        return self.children[1]

    def vars(self):
        return self.children[0].children
        
    def varnames(self, kw={}):
        vars = self.vars()
        return [vars[i].codegen(**kw) for i in range(len(vars))]

    def start_stop_step(self, kw):
        vars = self.children[0].children
        dims = len(vars)
        start_arg = self.children[3]
        stop_arg = self.children[4]
        step_arg = self.children[5]

        img = self.arg_image()

        startL = []
        stopL = []
        stepL = []
        
        for i in range(dims):
            start = '0'
            if not isinstance(start_arg, Missing):
                start = start_arg.children[i].codegen(**kw) if isinstance(start_arg, ConstVector) else start_arg.codegen(**kw)
    
            stop = img.type.get_size(img.codegen(**kw), i)
            if i == img.type.dims - 1 and self.channels < self.total_channels:
                stop = str(self.channels)
            if not isinstance(stop_arg, Missing):
                stop = stop_arg.children[i].codegen(**kw) if isinstance(stop_arg, ConstVector) else stop_arg.codegen(**kw)
    
            step = str(self.spacing[0][i])
            if not isinstance(step_arg, Missing):
                step = '(' + step + ')*(' + (step_arg.children[i].codegen(**kw) if isinstance(step_arg, ConstVector) else step_arg.codegen(**kw)) + ')'
            startL.append(start)
            stopL.append(stop)
            stepL.append(step)
            
        return (startL, stopL, stepL)

    def has_Isample(self):
        return self.reconstruct_mode == RECONSTRUCT_STORE and self.is_approx()

    def codegen(self, is_statement=False, **kw):
        kw = dict(kw)
        
        self.make_consistent()
        self.check()
        self.debug_save = debug_save
        vars = self.children[0].children
        
        refArray = self.children[2]
        
        start_arg = self.children[3]
        stop_arg = self.children[4]
        step_arg = self.children[5]
        step_argL = step_arg.children if not isinstance(step_arg, Missing) else []
        
        do_samples = self.children[FOREACH_DO_SAMPLES]
        do_reconstruct = self.children[7]
        
        img = self.arg_image()

        dims = len(vars)
        assert dims <= img.type.dims, (dims, img.type.dims, self)
        varlist = []
        
        header = ''
        footer = ''
        ans_header = ''
        
        next_used = [False]
        prev_used = [False]
        visit_set = set()
        
        def visit(current):
            visit_set.add(id(current))
            if isinstance(current, prev_sample):
                prev_used[0] = True
            if isinstance(current, next_sample):
                next_used[0] = True
            for child in current.children:
                if id(child) not in visit_set:
                    visit(child)
        visit(self)

        children_s = self.children_codegen(kw, self.arg_count)
        grid_store = self.reconstruct_mode == RECONSTRUCT_STORE and self.is_grid_approx()

#        print 'reconstruct_mode is STORE', self.reconstruct_mode == RECONSTRUCT_STORE, 'is_approx', self.is_approx()
        if self.reconstruct_mode == RECONSTRUCT_STORE and self.is_approx():
#            print str(self), 'is_approx'
            if isinstance(refArray, Missing):
                raise ValueError('reference array is missing')

 #           with Program(add=False) as header_code:
            with Block(add=False) as header_block:
                if get_profile_time(kw):
                    header_start = Var(wall_time(), prefix='_header_start_')
                    printf('%-30s: begin loop\n', self.name)
                #img.clear()
                if grid_store:
                    with If(do_reconstruct):
                        img.clear()

                #Itype = copy.deepcopy(refArray.type)
                #Itype.basetype = 'Float'
                #Itype.bits = 32
                
                Isample = self.Isample(True) #Var(Itype, refArray.sizes(), name=self.Isample_name)
                Itype = Isample.type
                if self.is_spatially_varying():
                    Isigma = self.Isigma(True)
    
                if prev_used[0] or next_used[0]:
                    Stype = copy.deepcopy(refArray.type)
                    Stype.basetype = 'Int'
                    Stype.bits = DEFAULT_INT_BITS
                    Stype.vectorize = None
                    Stype.sizes = Stype.sizes[:-1] + (2,)

                if prev_used[0]:
                    Iprev_sample = Var(Stype, [refArray.height(), refArray.width(), 2], prefix='_Iprev')
                if next_used[0]:
                    Inext_sample = Var(Stype, [refArray.height(), refArray.width(), 2], prefix='_Inext')

                with If(do_samples):
                    if self.t[0] != 1.0:
                        if self.is_grid_approx():
                            x = Var(prefix='_x3_')
                            y = Var(prefix='_y3_')

                            with If(do_reconstruct):
                                with ForEach((y, x), Isample, parallel=True, prefix='__grid_sample_'):
                                    Isample[y,x,0] = And(y%self.spacing[0][0]==0,x%self.spacing[0][1]==0)
                            if debug_save:
                                debug_image(Isample, 'Isample_grid.pfm', 1)
                        elif self.is_importance_approx():
                            if debug_save:
                                debug_image(refArray, 'refArray.pfm')
                            if self.importance_func is None:
                                default_importance(refArray.type, Itype, kw)(refArray, Isample, *tuple(x[0] for x in self.importance_args))
                            else:
                                self.importance_func(refArray.type, Itype, kw)(refArray, Isample, *tuple(x[0] for x in self.importance_args))
                            if debug_save:
                                debug_image(Isample, 'Isample.pfm', 1)
                            if self.rescale:
                                rescale_dither(Itype, kw)(Isample, self.frac[0])
    
                            if self.is_spatially_varying():
                                x = Var(prefix='_x1_')
                                y = Var(prefix='_y1_')
                                sigma_max = Var(self.sigma[0]/sqrt(self.frac[0])*sigma_max_mul, prefix='_sigma_max_')
                                with ForEach((y, x), Isigma, parallel=True, prefix='__sv_sigma_'):
                                    Isigma[y,x,0] = self.sigma[0]/sqrt(Isample[y,x,0])
                                    if use_sigma_max:
                                        with If(Isigma[y,x,0] > sigma_max):
                                            Assign(Isigma[y,x,0], sigma_max)
    
                            if debug_save:
                                debug_image(Isample, 'rescale.pfm', 1)
                            if self.dither:
                                if dither_method == 'floyd':
                                    dither_floyd(Itype, kw)(Isample)
                                elif dither_method == 'ost':
                                    dither_ost(Itype, kw)(Isample)
                                else:
                                    raise ValueError('unknown dither_method %s' % dither_method)
                            if debug_save:
                                debug_image(Isample, 'dither.pfm', 1)
                        elif self.is_adaptive_approx():
                            assert len(vars) == 2, 'expected 2 var ForEach loop for adaptive mode'
                            adaptive_dims = img.type.dims

                            Iadaptive = self.Iadaptive(True)
                            debug_adaptive = False

                            x = Var(prefix='_x_adaptive_')
                            y = Var(prefix='_y_adaptive_')
                            c = Var(prefix='_c_adaptive_')
                            i = Var(prefix='_i_adaptive_')
                            xtile = Var(prefix='_xtile_adaptive_')
                            ytile = Var(prefix='_ytile_adaptive_')
                            ytiles = Var((Isample.height()+self.adaptive_grid_size-1)/self.adaptive_grid_size, prefix='_ytiles_adaptive_')
                            xtiles = Var((Isample.width()+self.adaptive_grid_size-1)/self.adaptive_grid_size, prefix='_xtiles_adaptive_')
                            max_stddev = Var(0.0, prefix='_max_stddev_')
                            #Isample.clear()

                            with For(ytile, 0, ytiles):
                                ymax = Var(min((ytile+1)*self.adaptive_grid_size, Isample.height()), prefix='_ymax_adaptive_')
                                ymin = Var(ytile*self.adaptive_grid_size, prefix='_ymin_adaptive_')
                                ycenter0 = Var(self.adaptive_grid_size*ytile + self.adaptive_grid_size/2, prefix='_ycenter0_adaptive_')
                                ycenter = Var(min(ycenter0, Isample.height()-1), prefix='_ycenter_adaptive_')
                                with For(xtile, 0, xtiles):
                                    #min_val = Var(1e20,  prefix='_min_val_adaptive_')
                                    #max_val = Var(-1e20, prefix='_max_val_adaptive_')
                                    #min_x = Var(prefix='_min_x_adaptive_')
                                    #min_y = Var(prefix='_min_y_adaptive_')
                                    #max_x = Var(prefix='_max_x_adaptive_')
                                    #max_y = Var(prefix='_max_y_adaptive_')

                                    xmax = Var(min((xtile+1)*self.adaptive_grid_size, Isample.width()), prefix='_xmax_adaptive_')
                                    #with For(y, ytile*self.adaptive_grid_size, ymax):
                                    #    with For(x, xtile*self.adaptive_grid_size, xmax):
                                    #        if adaptive_channels == 3:
                                    #            val = Var(refArray(y, x, 0), prefix='_val_adaptive_')
                                    #        elif adaptive_channels == 2:
                                    #            val = Var(refArray(y, x, 0), prefix='_val_adaptive_')
                                    #        else:
                                    #            raise ValueError('adaptive_channels=%d, not supported'%adaptive_channels)
                                    #        with If(val < min_val):
                                    #            Assign(min_val, val)
                                    #            Assign(min_x, x)
                                    #            Assign(min_y, y)
                                    #        with ElseIf(val > max_val):
                                    #            Assign(max_val, val)
                                    #            Assign(max_x, x)
                                    #            Assign(max_y, y)
                                    xmin = Var(xtile*self.adaptive_grid_size, prefix='_xmin_adaptive_')
                                    xcenter0 = Var(self.adaptive_grid_size*xtile + self.adaptive_grid_size/2, prefix='_xcenter0_adaptive_')
                                    xcenter = Var(min(xcenter0, Isample.width()-1), prefix='_xcenter_adaptive_')

                                    if debug_adaptive:
                                        with If(Or(Not(in_bounds(ycenter, Isample.height())), Not(in_bounds(xcenter, Isample.width())))):
                                            printf('x, y out of bounds in xcenter/ycenter: %d, %d, %d, %d\n', xcenter, ycenter, Isample.width(), Isample.height())
                                            exit(1)

                                    #min_x = Var(rand()%(xmax-xmin)+xmin, prefix='_min_x_adaptive_')
                                    #min_y = Var(rand()%(ymax-ymin)+ymin, prefix='_min_y_adaptive_')
                                    Assign(vars[0], ycenter)
                                    Assign(vars[1], xcenter)
                                    CodeFragment('{' + children_s + '}')

                                    #Assign(vars[0], max_y)
                                    #Assign(vars[1], max_x)
                                    #CodeFragment('{' + children_s + '}')

                                    with For(y, ymin, ymax):
                                        with For(x, xmin, xmax):
                                            if debug_adaptive:
                                                with If(Or(Not(in_bounds(y, Isample.height())), Not(in_bounds(x, Isample.width())))):
                                                    printf('x, y out of bounds in Isample: %d, %d, %d, %d\n', x, y, Isample.width(), Isample.height())
                                                    exit(1)
                                            with If(And(x == xcenter, y == ycenter)):
                                                Assign(Isample[y,x,0], ADAPTIVE_COARSE_SAMPLE)
                                            with Else():
                                                Assign(Isample[y,x,0], 0.0)

                            if debug_save:
                                debug_image(img, 'img_coarse.pfm', 1)

                            with For(ytile, 0, ytiles):
                                ycenter0 = Var(self.adaptive_grid_size*ytile + self.adaptive_grid_size/2, prefix='_ycenter0_adaptive_')
                                ycenter = Var(min(ycenter0, Isample.height()-1), prefix='_ycenter_adaptive_')
                                with For(xtile, 0, xtiles):
                                    xcenter0 = Var(self.adaptive_grid_size*xtile + self.adaptive_grid_size/2, prefix='_xcenter0_adaptive_')
                                    xcenter = Var(min(xcenter0, Isample.width()-1), prefix='_xcenter_adaptive_')

                                    if debug_adaptive:
                                        with If(Or(Not(in_bounds(ycenter, img.height())), Not(in_bounds(xcenter, img.width())))):
                                            printf('x, y out of bounds in xcenter/ycenter of img: %d, %d, %d, %d\n', xcenter, ycenter, Isample.width(), Isample.height())
                                            exit(1)

                                    stddev = Var(0.0, prefix='_stddev_adaptive_')
                                    count = Var(0, prefix='_count_adaptive_')
                                    dx = Var(prefix='_dx_adaptive_')
                                    dy = Var(prefix='_dy_adaptive_')
                                    with For(dy, -1, 2):
                                        yprime = Var(ycenter0+dy*self.adaptive_grid_size, prefix='_yprime_adaptive_')
                                        with If(in_bounds(yprime, Isample.height())):
                                            with For(dx, -1, 2):
                                                with If(Or(dx != 0, dy != 0)):
                                                    xprime = Var(xcenter0+dx*self.adaptive_grid_size, prefix='_xprime_adaptive_')
                                                    with If(in_bounds(xprime, Isample.width())):
                                                        Assign(count, count+1)
                                                        with For(c, 0, refArray.channels_const()):
                                                            if adaptive_dims == 3:
                                                                Assign(stddev, stddev + abs(img[yprime,xprime,0]-img[ycenter,xcenter,0]))
                                                            elif adaptive_dims == 2:
                                                                Assign(stddev, stddev + abs(img[yprime,xprime]-img[ycenter,xcenter]))
                                                            else:
                                                                raise ValueError('adaptive_dims=%d, not supported'%adaptive_dims)
                                    Assign(stddev, stddev/count)

                                    if debug_adaptive:
                                        with If(Or(Not(in_bounds(ytile, Iadaptive.height())), Not(in_bounds(xtile, Iadaptive.width())))):
                                            printf('x, y out of bounds in xtile/ytile of Iadaptive: %d, %d, %d, %d\n', xtile, ytile, Iadaptive.width(), Iadaptive.height())
                                            exit(1)
                                    Assign(Iadaptive[ytile, xtile, 0], stddev)
                                    with If(stddev > max_stddev):
                                        Assign(max_stddev, stddev)

                            adaptive_bins = 512
                            histo_stddev = Var(Array(Int(), 1, sizes=[adaptive_bins]), [adaptive_bins], prefix='_histo_stddev_adaptive_')
                            histo_scale = Var((adaptive_bins-0.001)/max_stddev, prefix='_histo_scale_adaptive_')
                            with For(i, 0, adaptive_bins):
                                Assign(histo_stddev[i], 0)

                            with For(ytile, 0, ytiles):
                                with For(xtile, 0, xtiles):
                                    if debug_adaptive:
                                        with If(Or(Not(in_bounds(ytile, Iadaptive.height())), Not(in_bounds(xtile, Iadaptive.width())))):
                                            printf('x, y out of bounds in xtile/ytile of Iadaptive (2): %d, %d, %d, %d\n', xtile, ytile, Iadaptive.width(), Iadaptive.height())
                                            exit(1)
                                    stddev = Var(Float(), Iadaptive[ytile, xtile, 0], prefix='_stddev_adaptive_')
                                    bin = Var(Int(), stddev*histo_scale, prefix='_bin_adaptive_')
                                    if debug_adaptive:
                                        with If(Not(in_bounds(bin, adaptive_bins))):
                                            printf('bin out of range: %d %d\n', bin, adaptive_bins)
                                            exit(1)
                                    Assign(histo_stddev[bin], histo_stddev[bin]+1)

                            nsamples = Var(Int(), self.frac[0]*Isample.width()*Isample.height()-xtiles*ytiles, prefix='_nsamples_adaptive_')
                            if debug_save:
                                nsamples0 = Var(nsamples, prefix='_nsamples0_adaptive_')
                            with If(nsamples < 0):
                                Assign(nsamples, 0)

                            with For(i, adaptive_bins-1, -1, -1):
                                add_samples = Var(histo_stddev[i]*(self.adaptive_grid_size*self.adaptive_grid_size-2))
                                with If(nsamples >= add_samples):
                                    Assign(nsamples, nsamples - add_samples)
                                with Else():
                                    Break()
                            adaptive_thresh = Var(Float(), max(i,0)/histo_scale, prefix='_adaptive_thresh_')

                            with For(ytile, 0, ytiles):
                                ymax = Var(min((ytile+1)*self.adaptive_grid_size, Isample.height()), prefix='_ymax_adaptive_')
                                with For(xtile, 0, xtiles):
                                    xmax = Var(min((xtile+1)*self.adaptive_grid_size, Isample.width()), prefix='_xmax_adaptive_')

                                    if debug_adaptive:
                                        with If(Or(Not(in_bounds(ytile, Iadaptive.height())), Not(in_bounds(xtile, Iadaptive.width())))):
                                            printf('x, y out of bounds in xtile/ytile of Iadaptive (3): %d, %d, %d, %d\n', xtile, ytile, Iadaptive.width(), Iadaptive.height())
                                            exit(1)

                                    with If(Iadaptive[ytile, xtile, 0] >= adaptive_thresh):
                                        with For(y, ytile*self.adaptive_grid_size, ymax):
                                            with For(x, xtile*self.adaptive_grid_size, xmax):
                                                if debug_adaptive:
                                                    with If(Or(Not(in_bounds(y, Isample.height())), Not(in_bounds(x, Isample.width())))):
                                                        printf('x, y out of bounds in of Isample (2): %d, %d, %d, %d\n', xtile, ytile, Iadaptive.width(), Iadaptive.height())
                                                        exit(1)
                                                with If(Isample[y,x,0] == 0.0):
                                                    Assign(Isample[y,x,0], ADAPTIVE_FINE_SAMPLE)
                                                with Else():
                                                    Assign(Isample[y,x,0], ADAPTIVE_COARSE_CONVERTED_TO_FINE)
                            if self.is_spatially_varying():
                                with ForEach((y, x), Isigma, parallel=True, prefix='__sv_sigma_'):
                                    with If(Or(Isample[y,x,0] >= ADAPTIVE_COARSE_CONVERTED_TO_FINE)):
                                        Isigma[y,x,0] = 0.01
                                    with Else():
                                        Isigma[y,x,0] = self.sigma[0]*self.adaptive_grid_size/(2.0**0.5)
                                if debug_save:
                                    debug_image(Isigma, 'Isigma.pfm', 1)

                            if debug_save:
                                debug_image(Isample, 'Isample.pfm', 1)
                                debug_image(Iadaptive, 'Iadaptive.pfm', 1)
                                printf('adaptive_thresh=%f, max_stddev=%f, nsamples0=%d\n', adaptive_thresh, max_stddev, nsamples0)
                        else:
                            raise ValueError
                    else:
                        Isample.clear()

                if prev_used[0] or next_used[0]:
                    if refArray.dims_const() == 3:
                        x = Var(prefix='_x0_')
                        y = Var(prefix='_y0_')
                        xp = Var(prefix='_xp_')
                        yp = Var(prefix='_yp_')
                        kw = dict(kw)
                        if prev_used[0]:
                            with ForEach((y, x), Iprev_sample, start=start_arg, stop=stop_arg, step=step_arg, prefix='__prev_sample_'):
                                Assign(yp, y-step_argL[0])
                                Assign(xp, x-step_argL[1])
                                with If(And(in_bounds(xp, refArray.width()), Isample[y,xp,0])):
                                    Iprev_sample[y,x,1] = xp
                                with Else():
                                    Iprev_sample[y,x,1] = Select(in_bounds(xp, refArray.width()), Iprev_sample[y,xp,1], x)
                                with If(And(in_bounds(yp, refArray.height()), Isample[yp,x,0])):
                                    Iprev_sample[y,x,0] = yp
                                with Else():
                                    Iprev_sample[y,x,0] = Select(in_bounds(yp, refArray.height()), Iprev_sample[yp,x,0], y)
                            kw['prev_sample'] = [Iprev_sample[vars[0],vars[1],0], Iprev_sample[vars[0],vars[1],1]]
                            if debug_save:
                                debug_image(Iprev_sample, 'prev_sample.pfm')
                        if next_used[0]:
                            step_rev  = tuple([-v for v in step_arg])
                            start_rev = [stop_arg.children[i]+step_rev[i]  for i in range(len(stop_arg))]
                            stop_rev  = [start_arg.children[i]+step_rev[i] for i in range(len(stop_arg))]
                            with ForEach((y, x), Inext_sample, start=start_rev, stop=stop_rev, step=step_rev, prefix='__next_sample_'):
                                Assign(yp, y+step_argL[0])
                                Assign(xp, x+step_argL[1])
                                with If(And(in_bounds(xp, refArray.width()), Isample[y,xp,0])):
                                    Inext_sample[y,x,1] = xp
                                with Else():
                                    Inext_sample[y,x,1] = Select(in_bounds(xp, refArray.width()), Inext_sample[y,xp,1], x)
                                with If(And(in_bounds(yp, refArray.height()), Isample[yp,x,0])):
                                    Inext_sample[y,x,0] = yp
                                with Else():
                                    Inext_sample[y,x,0] = Select(in_bounds(yp, refArray.height()), Inext_sample[yp,x,0], y)
                            kw['next_sample'] = [Inext_sample[vars[0],vars[1],0], Inext_sample[vars[0],vars[1],1]]
                        del x
                        del y
                    else:
                        raise ValueError('Dimensions not implemented: %d' % refArray.dims_const())
                
                if get_profile_time(kw):
                    header_end = Var(wall_time(), prefix='_header_end_')
                    printf('%-30s pre-loop time: %f\n', self.name, header_end-header_start)
            
#            print '*'*72
#            print header_block
#            print '*'*72
            
            header_block = transform_loop_missing(header_block)
            header = header_block.codegen(**kw) + '\n'
            
            with Block(add=False) as footer_block:
                with If(do_reconstruct):
                    if debug_save:
                        debug_image(img, 'img.pfm')
                        debug_image(Isample, 'Isample_before.pfm', 1)

                    self.reconstruct_func(self, img, Isample, refArray)

                    if debug_save:
                        debug_image(img, 'img_reconstructed.pfm')

#            print '*'*72
#            print 'Footer:'
#            print footer_block
#            print '*'*72
            
            footer_block = transform_loop_missing(footer_block)
            footer = footer_block.codegen(**kw)
                
#            header = '\nBEGIN_HEADER\n' + header + '\nEND_HEADER\n'
#            footer = '\nBEGIN_FOOTER\n' + footer + '\nEND_FOOTER\n'
        
            continueVarList = [v for v in vars]
            origVarList = list(continueVarList)
            if len(continueVarList) < img.type.dims:
                continueVarList.append(0)
            with Block(add=False) as continue_block:
                if self.do_continue:
                    if not grid_store:
                        sample_var = Var(Isample(*continueVarList), prefix='_sample_var')
                        with If(Not(sample_var)):
                            img[origVarList] = 0.0
                            Continue()

                    if self.is_adaptive_approx():       # In adaptive mode
                        with If(sample_var != ADAPTIVE_FINE_SAMPLE):
                            Continue()
#            print '*'*72
#            print continue_block
#            print '*'*72
            if not kw.get('is_vectorize', 0):
                continue_block = transform_loop_missing(continue_block)
            ans_header = continue_block.codegen(**kw) + '\n'
            #ans = 'if (!%s(%s)) { continue; }\n' % (Isample.name, ','.join(continueVarList)) + ans

        else:       # No pre-loop calculations
            if get_profile_time(kw):
                with Block(add=False) as header_block:
                    if get_profile_time(kw):
                        header_end = Var(wall_time(), prefix='_header_end_')
                
                header_block = transform_loop_missing(header_block)
                header = header_block.codegen(**kw) + '\n'

        with Block(add=False) as prefooter_block:
            if get_profile_time(kw):
                footer_start = Var(wall_time(), prefix='_footer_start_')
        
        prefooter_block = transform_loop_missing(prefooter_block)
        prefooter = prefooter_block.codegen(**kw) + '\n'


        # Reconstruct missing channels by copying reference image
        with Block(add=False) as footer_block2:
            if self.channels < self.total_channels:
                with If(do_reconstruct):
                    x = Var(prefix='_x2_')
                    y = Var(prefix='_y2_')
                    with ForEach((y, x), img, parallel=True, prefix='__copy_refimage_'):
                        for channel in range(self.channels, self.total_channels):
                            img[y,x,channel] = refArray[y,x,channel]

            #if debug_save:
            #    debug_image(img, 'img_copy_missing_channels.pfm')
        
            if get_profile_time(kw):
                footer_end = Var(wall_time(), prefix='_footer_end_')
                printf('%-30s loop time: %f\n', self.name, footer_start-header_end)
                printf('%-30s post-loop time: %f\n', self.name, footer_end-footer_start)

        footer_block2 = transform_loop_missing(footer_block2)
        footer2 = footer_block2.codegen(**kw)


        if (next_used[0] or prev_used[0]) and 'next_sample' not in kw:
#            print len(vars), len(self.spacing[0]), len(step_arg.children)
            kw['next_sample'] = [vars[i]+self.spacing[0][i]*(step_argL[i] if len(step_argL) else 1) for i in range(len(vars))]
        if (next_used[0] or prev_used[0]) and 'prev_sample' not in kw:
            kw['prev_sample'] = [vars[i]-self.spacing[0][i]*(step_argL[i] if len(step_argL) else 1) for i in range(len(vars))]

        kw.setdefault('foreach_loop_vars', [])
        kw['foreach_loop_vars'].append(img)
        kw.setdefault('foreach_loops', [])
        kw['foreach_loops'].append(self)

        ans = ans_header + children_s

        (startL, stopL, stepL) = self.start_stop_step(kw)

        if self.random_p != 1.0:
            ans = 'if (rand() > RAND_MAX*%f) { continue; }'%self.random_p + ans
            
        for i in range(dims)[::-1]:
            var0 = vars[i]
            var = vars[i].codegen(**kw)
            varlist.append(var)

            (start, stop, step) = (startL[i], stopL[i], stepL[i])

            (start, stop) = rewrite_contiguous_frac(start, stop, self.contiguous_frac, var0)

            const_charset = '-()0123456789.e'
            step_const = all([x in const_charset for x in step])
            cond = '(%(step)s > 0) ? (%(var)s < %(stop)s): (%(var)s > %(stop)s)' % locals()
            if step_const:
                try:
                    step_val = eval(step, {}, {})
                    if step_val > 0:
                        cond = '(%(var)s < %(stop)s)' % locals()
                    else:
                        cond = '(%(var)s > %(stop)s)' % locals()
                except:
                    raise
                    step_const = False
                            
            ans = indent(ans)
            ans = 'for (%(var)s = %(start)s; %(cond)s; %(var)s += %(step)s) {\n%(ans)s\n}\n' % locals()
        
        parallel = self.parallel
        if parallel is None:
            parallel = kw.get('parallel', False)
        if parallel:
            ans = '#pragma omp parallel for private(%s) %s\n' % (','.join(varlist), self.parallel_options) + ans
        return header + ans + prefooter + footer + footer2

def rewrite_contiguous_frac(start, stop, contiguous_frac, var0):
    if contiguous_frac != 1:
        if contiguous_frac > 0:
            f = contiguous_frac
            stop = '%(start)s + %(f)f * (%(stop)s - %(start)s)' % locals()
            stop = '%s(%s)' % (var0.type.scalar(), stop)
        else:
            f = 1-abs(contiguous_frac)
            start = '%(start)s + %(f)f * (%(stop)s - %(start)s)' % locals()
            start = '%s(%s)' % (var0.type.scalar(), start)
    return (start, stop)
    
class For(Block):
    def __init__(self, var, start, stop, step=1, outputExpr=None, add=True, allow_random=True, parallel=False, name=None):
        L = [var, as_expr(start), as_expr(stop), as_expr(step), as_expr_missing(outputExpr)]
        self.arg_count = len(L)
        
        if name is None:
            name = make_varname()
        self.name = name
        
        self.step_mul = 1
        self.contiguous_frac = 1.0
        self.random_p = 1.0
        self.allow_random = allow_random
        self.terminate_thresh = None
        self.parallel = parallel
        
        Block.__init__(self, L, add=add)
    
    def use_same_approx(self, otherL):
        for other in otherL:
            other.step_mul = self.step_mul
            other.contiguous_frac = self.contiguous_frac
            other.sample_random(self.random_p)
            other.terminate_thresh = self.terminate_thresh
            
    def is_approx(self):
        return self.step_mul != 1 or self.contiguous_frac != 1.0 or self.random_p != 1.0 or self.terminate_thresh is not None
        
    def sample_step(self, step_mul):
        self.step_mul = float(step_mul)

    def sample_contiguous(self, frac):
        self.contiguous_frac = float(frac)

    def sample_random(self, p):
        if self.allow_random:
            self.random_p = float(p)
        else:
            self.random_p = 1.0
    
    def early_terminate(self, T):
        self.terminate_thresh = float(T)
        
    def check(self):
        assert len(self.children) >= self.arg_count
        
    def codegen(self, is_statement=False, **kw):
#        with Block(add=False) as header_block:
#            if get_profile_time(kw):
#                for_loop_start = Var(wall_time(), prefix='_for_loop_start_')

#        with Block(add=False) as footer_block:
#            if get_profile_time(kw):
#                for_loop_end = Var(wall_time(), prefix='_for_loop_end_')
#                printf('%-30s loop time: %f\n', self.name, for_loop_end-for_loop_start)

#        footer_block = transform_loop_missing(footer_block)
#        footer = footer_block.codegen(**kw)

#        header_block = transform_loop_missing(header_block)
#        header = header_block.codegen(**kw)
        footer = header = ''
        
        ans = self.children_codegen(kw, self.arg_count)
        children = self.children[:self.arg_count]
        var0 = children[0]
        (var, start, stop, step, outputExpr) = [x.codegen(**kw) for x in children]
        outputExprObj = children[-1]
        step_mul = self.step_mul
        (start, stop) = rewrite_contiguous_frac(start, stop, self.contiguous_frac, var0)
        skip = ''
        if self.random_p != 1:
            skip = indent('\nif (rand() > RAND_MAX*%f) { continue; }'%self.random_p)
        post_skip = ''
        preface = ''
        if self.terminate_thresh is not None:
            thresh = self.terminate_thresh

            prev_value = Var(outputExprObj.type, add=False)
            preface = prev_value.codegen(is_statement=True)
            prev_value = prev_value.codegen()
            
            first = Var(Bool(), 1, add=False)
            preface += '\n' + first.codegen(is_statement=True)
            first = first.codegen()
            
            post_skip = indent('\nif (!%(first)s && std::abs(%(outputExpr)s-%(prev_value)s) < %(thresh)f) { break; }\n%(prev_value)s = %(outputExpr)s;\n%(first)s = 0;\n' % locals())
        if self.parallel:
            preface += '\n#pragma omp parallel for'
        ans = indent(ans)
        start = '(' + start + ')'
        stop = '(' + stop + ')'
        step = '(' + step + ')'
        
        cond = '(%(step)s > 0) ? (%(var)s < %(stop)s): (%(var)s > %(stop)s)' % locals()
        try:
            step_const = eval(step)
            if step_const > 0:
                cond = '(%(var)s < %(stop)s)' % locals()
            elif step_const < 0:
                cond = '(%(var)s > %(stop)s)' % locals()
        except:
            pass
        
        ans = '%(header)s%(preface)s\nfor (%(var)s = %(start)s; %(cond)s; %(var)s += %(step)s*%(step_mul)d) {%(skip)s\n%(ans)s\n%(post_skip)s\n}\n%(footer)s\n' % locals()
        return ans
   
class If(Block):
    def __init__(self, cond):
        Block.__init__(self, [as_expr(cond)])
    
    def check(self):
        assert len(self.children) >= 1
        
#    def str(self):
#        self.check()
#        return '%s(%r)' % (self.__class__.__name__, self.cond)
        
    def codegen(self, is_statement=False, **kw):
        self.check()
        return 'if (%s) {\n%s\n}\n' % (self.children[0].codegen(**kw), indent(self.children_codegen(kw, 1)))
        
class ElseIf(If):
    def codegen(self, is_statement=False, **kw):
        self.check()
        return 'else if (%s) {\n%s\n}\n' % (self.children[0].codegen(**kw), indent(self.children_codegen(kw, 1)))

class Else(Block):
    def codegen(self, is_statement=False, **kw):
        self.check()
        return 'else {\n%s\n}\n' % indent(self.children_codegen(kw))

class Return(Statement):
    def __init__(self, value=None):
        Statement.__init__(self, [as_expr(value)] if value is not None else [])
    
    def check(self):
        assert len(self.children) in [0, 1]
        
#    def str(self):
#        self.check()
#        #print 'Return', id(self), [id(x) for x in self.children]
#        return 'Return()' #%r)' % self.children[0]
    
    def codegen(self, is_statement=False, **kw):
        self.check()
        if len(self.children):
            return 'return %s;' % self.children[0].codegen(False, **kw)
        else:
            return 'return;'
        
def builtin_func(name, return_type=None):
    return FuncRef(name, return_type)

def as_expr(v):
    if isinstance(v, Expr):
        return v
    elif isinstance(v, (int, float, long, bool, str) + numpy_types):
        return Const(v)
    elif isinstance(v, (list, tuple)):
        return ConstVector(v)
    else:
        raise ValueError('as_expr() expected Expr, int, float, long, bool, list, or tuple, received', v)

def as_expr_missing(v):
    return as_expr(v) if v is not None else Missing()

def expr_pow(a, b):
    a = as_expr(a)
    b = as_expr(b)
    type = result_type(a.type, b.type)
    return Call(builtin_func('std::pow', type), (a, b))

class Expr(Node):
    __array_priority__ = 1000       # Prevent numpy from broadcasting as array operations
    def get_const(self):
        if isinstance(self, Const):
            return self.value
        raise ValueError
        
    def __lt__(self, other):
        return BinaryOp('<', (self, other), Bool())
        
    def __le__(self, other):
        return BinaryOp('<=', (self, other), Bool())
        
    def __eq__(self, other):
        return BinaryOp('==', (self, other), Bool())
        
    def __ne__(self, other):
        return BinaryOp('!=', (self, other), Bool())

    def __gt__(self, other):
        return BinaryOp('>', (self, other), Bool())

    def __ge__(self, other):
        return BinaryOp('>=', (self, other), Bool())

    def __call__(self, *args):
        return Call(self, args)

    def __setitem__(self, key, value):
        if debug:
            print '__setitem__'
            print 'key', key
            print 'value', value
        if isinstance(value, Assign):
            if debug:
                print 'is Assign, returning value'
            return value
        if debug:
            print 'before call'
            self.block_trace()
        lhs = Call(self, key) #, rhs=False)
        value = as_expr(value)
        if debug:
            print 'after call'
            self.block_trace()
        if lhs.codegen() == value.codegen():
            orig = get_add_exprs()
            set_add_exprs(False)
            del lhs
            set_add_exprs(orig)
            if debug:
                print 'returning, codegens are equal'
            return
        Assign(lhs, value)
    
    def __getitem__(self, key):
        if debug:
            print '__getitem__', str(self), key
        square_brackets = self.type is not None and self.type.is_vector
        return Call(self, key, square_brackets=square_brackets)
    
    def square_brackets(self, key):
        return Call(self, key, True)
       
    def __iadd__(self, other):
        if debug:
            print '__iadd__(%r, %r)' % (self, other)
        ans = Assign(self, BinaryOp('+', (self, other)))
        if debug:
            print '__iadd__ result:'
            print ans
            print ans.codegen()
        return self

    def __isub__(self, other):
        ans = Assign(self, BinaryOp('-', (self, other)))
        return self

    def __imul__(self, other):
        ans = Assign(self, BinaryOp('*', (self, other)))
        return self

    def __imod__(self, other):
        ans = Assign(self, BinaryOp('%', (self, other)))
        return self

    def __idiv__(self, other):
        ans = Assign(self, BinaryOp('/', (self, other)))
        return self

    def __ipow__(self, other):
        ans = Assign(self, BinaryOp('-', (self, other)))
        return self

    def __ilshift__(self, other):
        ans = Assign(self, BinaryOp('<<', (self, other)))
        return self

    def __irshift__(self, other):
        ans = Assign(self, BinaryOp('>>', (self, other)))
        return self

    def __iand__(self, other):
        ans = Assign(self, BinaryOp('&', (self, other)))
        return self

    def __ior__(self, other):
        ans = Assign(self, BinaryOp('|', (self, other)))
        return self

    def __add__(self, other):
        if debug:
            print '__add__(%r, %r)' % (self, other)
        return BinaryOp('+', (self, other))
        
    def __sub__(self, other):
        return BinaryOp('-', (self, other))

    def __mul__(self, other):
        return BinaryOp('*', (self, other))

    def __mod__(self, other):
        if self.type.is_float():
            return Call(builtin_func('fmod', self.type), (self, other))
        else:
            return BinaryOp('%', (self, other))

    def __div__(self, other):
        return BinaryOp('/', (self, other))

    def __pow__(self, other):
        return expr_pow(as_expr(self), as_expr(other))

    def __lshift__(self, other):
        return BinaryOp('<<', (self, other))

    def __rshift__(self, other):
        return BinaryOp('>>', (self, other))

    def __and__(self, other):
        return BinaryOp('&', (self, other))

    def __or__(self, other):
        return BinaryOp('|', (self, other))


    def __radd__(other, self):
        return BinaryOp('+', (self, other))
        
    def __rsub__(other, self):
        return BinaryOp('-', (self, other))

    def __rmul__(other, self):
        return BinaryOp('*', (self, other))

    def __rmod__(other, self):
        return BinaryOp('%', (self, other))

    def __rdiv__(other, self):
        return BinaryOp('/', (self, other))

    def __rpow__(other, self):
        return expr_pow(as_expr(self), as_expr(other))

    def __rlshift__(other, self):
        return BinaryOp('<<', (self, other))

    def __rrshift__(other, self):
        return BinaryOp('>>', (self, other))

    def __rand__(other, self):
        return BinaryOp('&', (self, other))

    def __ror__(other, self):
        return BinaryOp('|', (self, other))


    def __neg__(self):
        return UnaryOp('-', self)

    def __pos__(self):
        return UnaryOp('+', self)

    def __abs__(self):
        return Call(builtin_func('std::abs', self.type), (self,))

class next_sample(Expr):
    def __init__(self, dim):
        self.dim = dim
        self.type = Int()
        Node.__init__(self)

    def str(self):
        return 'next_sample(%d)' % self.dim
    
    def codegen(self, is_statement=False, **kw):
        if 'next_sample' in kw:
            return kw['next_sample'][self.dim].codegen(**kw)
        else:
            raise ValueError('next_sample not found (in ForEach loop?)')

class prev_sample(Expr):
    def __init__(self, dim):
        self.dim = dim
        self.type = Int()
        Node.__init__(self)
    
    def str(self):
        return 'prev_sample(%d)' % self.dim
    
    def codegen(self, is_statement=False, **kw):
        if 'prev_sample' in kw:
            return kw['prev_sample'][self.dim].codegen(**kw)
        else:
            raise ValueError('prev_sample not found (in ForEach loop?)')

class ConstVector(Expr):
    def __init__(self, L, type=None):
        children = [as_expr(x) for x in L]
        if type is None:
            assert len(children)
            self.type = children[0].type
        else:
            self.type = type
            
        Node.__init__(self, children)
    
    def __len__(self):
        return len(self.children)
    
    def __iter__(self):
        for child in self.children:
            yield child
    
    def __getitem__(self, i):
        return self.children[i]
        
    def codegen(self, is_statement=False, **kw):
        return 'vector<%s>({%s})' % (self.type.codegen(), ','.join(c.codegen(False, **kw) for c in self.children))

    def __getitem__(self, key):
        return Call(self, (key,), True)
        
class BaseFunc(object):
    def str(self):
        self.check()
        if self.type is None:
            return '%s(%r)' % (self.__class__.__name__, self.name)
        else:
            return '%s(%r, %r)' % (self.__class__.__name__, self.name, self.type)

class FuncRef(BaseFunc, Expr):
    def __init__(self, name, type=None, function=None):
        #print 'FuncRef', len(self.children)
        self.name = name
        self.type = type
        self.function = function
        Node.__init__(self)
    
    def check(self):
        assert len(self.children) == 0
        
    def codegen(self, is_statement=False, **kw):
        assert not is_statement, self
        return self.name
    
class Function(Block, BaseFunc):
    def __init__(self, type=None, name=None, add=True):
        if name is None:
            name = make_varname()
        self.name = name
        self.type = type if type is not None else Void()
        Block.__init__(self, add=add)

    def __enter__(self):
        Block.__enter__(self)
        return FuncRef(self.name, self.type, self)
    
    def str(self):
        if self.type is None:
            return 'Function(%s)' % self.name
        else:
            return 'Function(%s, %r)' % (self.name, self.type)
    
    def arguments(self):
        return [x for x in self.children if isinstance(x, Argument)]
        
    def codegen(self, is_statement=False, **kw):
        #if is_statement:
        assert is_statement
        s = '%s %s' % (self.type.codegen(**kw) if self.type is not None else 'void', self.name)
        args = []
        statements = []
        for child in self.children:
            if isinstance(child, Argument):
                args.append(child.codegen(True, **kw))
            else:
                statements.append(child.codegen(True, **kw))
        return s + '(' + ','.join(args) + ') {\n' + indent('\n'.join(statements)) + '\n}\n'
        #else:
        #    return self.name

class Continue(Block, BaseFunc):
    def codegen(self, is_statement=False, **kw):
        return 'continue;\n'

class Break(Block, BaseFunc):
    def codegen(self, is_statement=False, **kw):
        return 'break;\n'

def float_codegen(f):
    if isinstance(f, (float,) + numpy_float_types):
        f = repr(f)
    if not '.' in f and not 'e' in f:
        f += '.0'
    f += 'f'
    return f

class Const(Expr):
    def __init__(self, value):
        Expr.__init__(self)
        self.value = value
        if isinstance(self.value, bool):
            self.value = int(self.value)
        if isinstance(value, (int, long) + numpy_int_types):
            self.type = Int()
        elif isinstance(value, (float,) + numpy_float_types):
            self.type = Float()
        elif isinstance(value, str):
            self.type = Str()
        else:
            raise TypeError('Unsupported const type: %r' % value)
    
    def str(self):
        return 'Const(%r)' % self.value
    
    def codegen(self, is_statement=False, **kw):
        if isinstance(self.value, str):
            return '"' + repr(self.value)[1:-1] + '"'
        ans = repr(self.value)
        if self.type.basetype == 'Float' and self.type.bits == 32:
            ans = float_codegen(ans)
        return '(' + ans + ')'

def Not(a):
    return UnaryOp('!', a, Bool())

def And(*L):
    def f(a, b):
        return BinaryOp('&&', (a, b), Bool())
    return reduce(f, L)

def Or(*L):
    def f(a, b):
        return BinaryOp('||', (a, b), Bool())
    return reduce(f, L)

class Select(Expr):
    def __init__(self, a, b, c):
        Node.__init__(self, [as_expr(a), as_expr(b), as_expr(c)])
        self.type = self.children[1].type
        
    def check(self):
        assert len(self.children) == 3
    
    def codegen(self, is_statement=False, **kw):
        self.check()
        L = [c.codegen(**kw) for c in self.children]
        return '(%s ? %s: %s)' % (L[0], L[1], L[2])
        
class BinaryOp(Expr):
    def __init__(self, op, children, type=None):
        Node.__init__(self, [as_expr(x) for x in children])
        self.op = op
        if type is not None:
            self.type = type
        else:
            if debug:
                print 'Current node:', self
            self.type = result_type(self.children[0].type, self.children[1].type)
        
    def str(self):
        return 'BinaryOp(%r)' % self.op
    
    def check(self):
        assert len(self.children) == 2
        
    def codegen(self, is_statement=False, **kw):
        self.check()
        return '(%s%s%s)' % (self.children[0].codegen(**kw), self.op, self.children[1].codegen(**kw))

class UnaryOp(Expr):
    def __init__(self, op, child, type=None):
        Node.__init__(self, [as_expr(child)])
        self.op = op
        self.type = child.type
        if type is not None:
            self.type = type
        
    def str(self):
        return 'UnaryOp(%r)' % self.op
    
    def check(self):
        assert len(self.children) == 1
        
    def codegen(self, is_statement=False, **kw):
        self.check()
        return '(%s%s)' % (self.op, self.children[0].codegen(**kw))

class Assign(Statement):
    def __init__(self, lhs, rhs):
        if debug:
            print 'Debug info: Assign\n  lhs=%r\n\n  rhs=%r' % (lhs, rhs)
#        lhs = copy.deepcopy(lhs)
        lhs = as_expr(lhs)
        rhs = as_expr(rhs)
#        if hasattr(lhs, 'rhs'):
#            lhs.rhs = False
        Statement.__init__(self, [lhs, rhs])
    
#    def str(self):
#        return 'Assign()' #%r, %r)' % (self.children[0], self.children[1])

    def check(self):
        assert len(self.children) == 2
        
    def codegen(self, is_statement=False, **kw):
        self.check()
        (lhs, rhs) = self.children
        rhs_c = rhs.codegen(**kw)
        if lhs.type.dims > 0 and lhs.type.vectorize is not None and rhs.type.dims == 0:
            rhs_c = lhs.type.scalar_to_atom(rhs_c)
        kw_prime = dict(kw)
        kw_prime['rhs'] = False
        return '%s = %s;' % (lhs.codegen(**kw_prime), rhs_c)

def make_varname(count=[0]):
    ans = '_x%d' % count[0]
    count[0] += 1
    return ans


#class SpacingMixin(object):
#    def prove_multiple(self, key):
#        return True
#    
#    def __getitem__(self, key):
#        if self.type.spacing is not None:
#            if self.prove_multiple(key) and 0:
#                return Expr.__getitem__(self, key)
#            else:
#                return self.get_lerp(*key)    
    
class Var(Statement, Expr):
    def __init__(self, type=None, initial=None, is_argument=False, add=True, name=None, prefix='', is_statement=True):
        if not isinstance(type, Type):
            (initial, type) = (type, None)
        children = [] if initial is None else [as_expr(initial)]
        if name is None:
            name = prefix + make_varname()
        self.name = name
        self.type = copy.deepcopy(type)
        if initial is not None and self.type is None:
            self.type = copy.deepcopy(children[0].type)
        if self.type is None:
            self.type = Int()
        self.is_argument = is_argument
        self.is_statement = is_statement
        
#        SpacingMixin.__init__(self)        
        Statement.__init__(self, children, add=add and is_statement)
        
    def check(self):
        assert len(self.children) in [0, 1]

    def str(self):
        self.check()
        c = 'Var' if not self.is_argument else 'Argument'
        #if len(self.children) == 0:
        return '%s(%r, %r)' % (c, self.name, self.type)
        #else:
        #    return '%s(%r, %r, %r)' % (c, self.name, self.type, self.children[0])
    
    def codegen(self, is_statement=False, **kw):
        self.check()
        if is_statement and self.is_statement:
            type_code = self.type.codegen(**kw)
            if self.is_argument and self.type.dims > 0:
                type_code += ' &'
            else:
                type_code += ' '   
            decl = '%s%s' % (type_code, self.name)
            initial = self.children[0] if len(self.children) else None
            if initial is not None and isinstance(initial, ConstVector):
                initial_n = len(initial.children)
                if initial_n != self.type.dims:
                    raise ValueError('array has dimension %d, but sizes initial value has length %d' % (initial_n, self.type.dims))
            if self.is_argument:
                if initial is None:
                    return decl
                else:
                    return decl + '=' + initial.codegen(**kw)
            else:
                if initial is None:
                    ans = decl + ';'
                else:
                    rest = '%s = %s;' % (self.name, initial.codegen(**kw))
#                    if self.type.dims > 0:
#                        self_var = Var(name=self.name, add=False)
#                        rest = self_var.resize(initial).codegen(**kw)
                    ans = '%s; %s' % (decl, rest)
                if self.type.dims > 0:
                    ans = 'static ' + ans
                return ans
        else:
            return self.name
    
    def height(self):
        return Method(self, 'height', Int())()

    def width(self):
        return Method(self, 'width', Int())()

    def channels(self):
        try:
            return self.channels_const()
        except ValueError:
            return Method(self, 'channels', Int())()
    
    def size(self):
        return Method(self, 'size', Int())()
    
    def channels_const(self):
        return self.type.channels_const()

    def dims_const(self):
        return self.type.dims
        
    def get_lerp(self, *args):
        return Method(self, 'get_lerp', self.type.scalar_type())(*args)

    def min(self):
        return Method(self, 'min', self.type.scalar_type())()

    def max(self):
        return Method(self, 'max', self.type.scalar_type())()

    def sum(self):
        return Method(self, 'sum', self.type.scalar_type())()
    
    def sizes(self):
        return Method(self, 'get_sizes', Vector(Int()))()

    def clear(self, *args):
        return Method(self, 'clear', Void())(*args)

    def rgb2lab(self, *args):
        return Method(self, 'rgb2lab', Void())(*args)
        
    def lab2rgb(self, *args):
        return Method(self, 'lab2rgb', Void())(*args)

    def rgb2yuv(self, *args):
        return Method(self, 'rgb2yuv', Void())(*args)
        
    def yuv2rgb(self, *args):
        return Method(self, 'yuv2rgb', Void())(*args)

    def resize(self, *args):
        return Method(self, 'resize', Void())(*args)

    def assign(self, *args):
        return Method(self, 'assign', Void())(*args)

        
def call_needed(funcname):
#    try:
#        if funcname.endswith('.sizes'):
#            return False
#    except:
#        raise ValueError(funcname)
    return True

class Argument(Var):
    def __init__(self, type, initial=None, is_argument=True, add=True, name=None):
        Var.__init__(self, type, initial, is_argument, add=add, name=name)
    
class Call(Expr):
    def __init__(self, func, args, square_brackets=False): #, rhs=True):
        if not hasattr(args, '__len__'):
            args = [args]
#        self.rhs = rhs
        #if isinstance(func, Method) and func.methodname == 'sizes':
        #    square_brackets = True
        Node.__init__(self, [func] + [as_expr(x) for x in args])
        if func.type is not None:
            self.type = func.type
            if not isinstance(func, (Function, FuncRef)):
                rdims = len(args)
                self.type = copy.deepcopy(self.type)
                self.type.dims = _max(self.type.dims-rdims, 0)
                self.type.set_spacing()
                #self.type = self.type.scalar_type() #raise ValueError((func, args, self.type)) 
        else:
            self.type = self.children[1].type
        self.square_brackets = square_brackets
    
    def check(self):
        assert len(self.children) >= 1
        
    def str(self):
        #print 'Call', id(self), [id(x) for x in self.children]
        self.check()
        if self.square_brackets:
            return 'Call(type=%r, square_brackets=True)' % (self.type)
        else:
            return 'Call(type=%r)' % (self.type) #(%r, %r)' % (self.children[0], self.children[1:])

    def codegen(self, is_statement=False, **kw):
        self.check()
        func = self.children[0]
        funcname = self.children[0].codegen(False, **kw)
#        print self
        if not call_needed(funcname) and len(self.children) == 1:
            return funcname

        in_foreach_samename = False
        for x in kw.get('foreach_loop_vars', []):
            if x is self.children[0]:
                in_foreach_samename = True
        foreach_loop = None
        for x in kw.get('foreach_loops', []):
            foreach_loop = x


        make_nn = False
        if not kw.get('rhs', True) or in_foreach_samename or (func.type is not None and func.type.is_nearest): #isinstance(self.children[0], Var) and self.rhs and self.children[0].type.has_spacing():
            make_nn = True

        (lbrace, rbrace) = '()'
        #print self.children
        if self.square_brackets:# or (self.children[0].type is not None and self.children[0].type.is_vector):
            (lbrace, rbrace) = '[]'
        endline = '' if not is_statement else ';'
        L = [x.codegen(False, **kw) for x in self.children[1:]]

        if not make_nn and simplify_congruence and foreach_loop is not None and func.type is not None and func.type.is_array() and not '.' in funcname:
            spacing = func.type.spacing
            (startL, stopL, stepL) = foreach_loop.start_stop_step(kw)
            ok = True
            for i in range(len(startL)):
                try:
                    startL[i] = str(int(eval(startL[i])))
                    stepL[i] = str(int(eval(stepL[i])))
                except:
                    ok = False
            
            if ok:
                vars = foreach_loop.varnames()
                assert len(vars) == len(startL)
                
                def var_assume(varname):
#                    print 'var_assume', vars, varname
                    for i in range(len(vars)):
                        if vars[i] == varname:
                            return '%s %% %s == %s' % (varname, stepL[i], startL[i])
                    return ''
                    
                if len(spacing) >= len(L):
                    res = [congruence.is_congruent(L[i], spacing[i], 0, var_assume, verbose=False) for i in range(len(L))]
                    is_nn = all(res)
#                    print 'congruence: %s, %s, stepL=%r, startL=%r, spacing=%s, res=%r, is_nn=%d, foreach=%r' % (funcname, L, stepL, startL, spacing, [int(x) for x in res], is_nn, foreach_loop.arg_image().name)
                    if is_nn:
                        #pass
                        make_nn = True
#                else:
#                    print 'simplify_congruence: length mismatch: %d %d %d' % (len(L), len(startL), len(stepL))
          
        if make_nn:
            funcname += '.get_nearest'

        #print 'Call, funcname=%s' % funcname, ','.join(L)
        if funcname.endswith('.get_sizes()'):   # Turn get_sizes()[constant] into sizes[constant]
            try:
                L_value = int(','.join(L))
                funcname = funcname[:len(funcname) - len('.get_sizes()')] + '.sizes'
            except:
                pass

        if self.children[0].type is not None and self.children[0].type.vectorize is not None:
            if len(L)-1 >= self.children[0].type.vectorize:
                return '%s%s%s%s[%s]%s' % (funcname, lbrace, ','.join(L[i] for i in range(len(L)-1)), rbrace, L[-1], endline)
        return '%s%s%s%s%s' % (funcname, lbrace, ','.join(L), rbrace, endline)
       
class Method(Expr):
    def __init__(self, instance, methodname, return_type):
        Node.__init__(self, [as_expr(instance)])
        self.methodname = methodname
        self.type = return_type
        
    def check(self):
        assert len(self.children) == 1
    
    def str(self):
        self.check()
        return 'Method(%r, %r)' % (self.methodname, self.type)
    
    def codegen(self, is_statement=False, **kw):
        self.check()
        return '%s.%s' % (self.children[0].codegen(False, **kw), self.methodname)
        
class Type(object):
    def __init__(self, basetype, bits, dims=0, sizes=None, vectorize=None, is_vector=False, spacing=None, is_nearest=False):
        self.basetype = basetype
        self.bits = int(bits)
        self.dims = int(dims)
        self.sizes = sizes
        self.vectorize = vectorize
        self.is_vector = is_vector
        self.is_nearest = is_nearest
        if spacing is None:
            self.set_spacing()
        else:
            self.spacing = spacing
        self.check()
    
    def is_array(self):
        return self.dims != 0
        
    def is_float(self):
        return self.basetype == 'Float'
        
    def vectorize_scalar(self, s):
        if self.vectorize is None:
            return s
        else:
            size = self.sizes[self.vectorize]
            assert size is not None, 'vectorize_scalar expected size not None'
            return '(%s {%s})' % (self.atom(), ', '.join([s] * size))
            
    def channels_const(self, one_if_vectorized=False):
        if self.sizes is None or len(self.sizes) < 3 or self.sizes[-1] is None:
            raise ValueError('channels is not a compile time constant for %r' % self)
        ans = self.sizes[-1]
        if one_if_vectorized and self.vectorize == len(self.sizes)-1:
            ans = 1
        return ans

    def has_spacing(self):
        return self.spacing != [1 for d in range(self.dims)]
        
    def set_spacing(self, spacing=None):
        if spacing is None:
            self.spacing = spacing = [1 for d in range(self.dims)]
        assert len(spacing) <= self.dims, (len(spacing), self.dims)
        if hasattr(self, 'spacing'):
            assert len(self.spacing) == self.dims
        for i in range(len(spacing)):
            self.spacing[i] = spacing[i]

    def check(self):
        assert len(self.spacing) == self.dims, (len(self.spacing), self.dims)
        
    def get_size(self, name, dim, make_const=True):
        self.check()
        size = '%s.sizes[%d]' % (name, dim)
#        print 'get_size', name, dim, self
        if make_const and self.sizes is not None and self.sizes[dim] is not None:
            size = str(self.sizes[dim])
        return size

    def __repr__(self):
        self.check()
        if self.basetype == 'Str':
            return self.basetype
        ans = '%s(%d)' % (self.basetype, self.bits)
        if self.dims > 0:
            sv = ''
            if self.sizes is not None:
                sv += ', sizes=%s' % repr(self.sizes)
            if self.vectorize is not None:
                sv += ', vectorize=%r' % self.vectorize
            if self.has_spacing():
                sv += ', spacing=%s' % repr(self.spacing)
            ans = '%s(%s, %d%s)' % ('Array' if not self.is_vector else 'Vector', ans, self.dims, sv)
        return ans

    def atom_size(self):
        self.check()
        assert self.basetype != 'Str'
        
        assert self.vectorize is not None
        sizes = self.sizes[self.vectorize]
        assert isinstance(sizes, (int, long)), 'expected sizes to be given if vectorize is specified'
        return sizes
        
    def scalar_to_atom(self, s):
        self.check()
        assert self.basetype != 'Str'

        sizes = self.atom_size()
        atom = self.atom()
        return '(%s) {%s}' % (atom, ','.join([s for i in range(sizes)]))
    
    def scalar(self):
        self.check()
        if self.basetype == 'Void':
            ans = 'void'
        elif self.basetype == 'Float':
            ans = 'float' if self.bits == 32 else 'double'
        elif self.basetype == 'Str':
            ans = 'std::string'
        else:
            ans = '%s%d_t' % (self.basetype.lower(), self.bits)
        return ans
    
    def scalar_type(self):
        self.check()
        ans = copy.deepcopy(self)
        ans.dims = 0
        ans.vectorize = None
        ans.spacing = []
        return ans
        
    def atom(self, **kw):
        self.check()
        assert self.basetype != 'Str'

        ans = self.scalar()
        if self.vectorize is not None:
            sizes = self.atom_size()
            vectype = 'vec%d_%s' % (sizes, ans)
            bytes = sizes*self.bits/8
            line = 'typedef %s %s __attribute__ ((vector_size (%d)));' % (ans, vectype, bytes)
            if 'headers' in kw and line not in kw['headers']:
                kw['headers'].append(line)
            ans = vectype
        return ans
        
    def codegen(self, **kw):
        self.check()
        if self.basetype == 'Str':
            return 'std::string'

        ans = self.atom(**kw)
        if self.dims > 0:
            if not self.is_vector:
                rest = ''
                if self.spacing != [1]*self.dims:
                    rest = ',' + ','.join(str(s) for s in self.spacing)
                ans = 'Array<%s%s%s>' % (ans, ', -1' if self.vectorize is None else (', %d'%self.vectorize), rest)
            else:
                ans = 'vector<%s>' % (ans)
        return ans
        
def Float(bits=DEFAULT_FLOAT_BITS, vectorize=None, sizes=None):
    return Type('Float', bits, vectorize=vectorize, sizes=sizes)

def Int(bits=DEFAULT_INT_BITS):
    return Type('Int', bits)

def UInt(bits=DEFAULT_INT_BITS):
    return Type('UInt', bits)

def Void():
    return Type('Void', DEFAULT_INT_BITS)
    
def Bool():
    return Int()

def Str():
    return Type('Str', DEFAULT_INT_BITS)
    
def Array(t, *a, **kw):
    return Type(t.basetype, t.bits, *a, **kw)

def Vector(t):
    return Type(t.basetype, t.bits, dims=1, is_vector=True)

def secure_hash(s):
    return sha.sha(s).hexdigest()[:20]
    
class Time(Block):
    def __init__(self, s):
        self.s = s
        Block.__init__(self)

    def str(self):
        return 'Timer(%r)' % self.s
        
    def codegen(self, is_statement=False, **kw):
        ans = self.children_codegen(kw)
        var = '_begin_time_' + secure_hash(self.s)
        return 'double %s = wall_time();\n' % var + ans + '\nprintf("Time %s: %%f\\n", wall_time()-%s);\n' % (self.s, var)

class CodeFragment(Expr, Statement):
    def __init__(self, s, type=None, add=True, header=False, once=False):
        self.type = type
        self.s = s
        self.header = header
        self.once = once
        Statement.__init__(self, add=add)
    
    def str(self):
        return 'CodeFragment(%r, %r)' % (secure_hash(self.s), self.type)
        
    def codegen(self, is_statement=False, **kw):
        if self.header:
            kw.setdefault('headers', [])
            add = True
            if self.once and self.s in kw['headers']:
                add = False
            if add:
                kw['headers'].append(self.s)
            return ''
        else:
            return self.s

fabs       = builtin_func('std::fabs')
exp       = builtin_func('std::exp')
sqrt      = builtin_func('std::sqrt')
cos       = builtin_func('std::cos')
sin       = builtin_func('std::sin')
tan       = builtin_func('std::tan')
cosh      = builtin_func('std::cosh')
sinh      = builtin_func('std::sinh')
tanh      = builtin_func('std::tanh')
atan      = builtin_func('std::atan')
atan2     = builtin_func('std::atan2')
floor     = builtin_func('std::floor')
ceil      = builtin_func('std::ceil')
log       = builtin_func('std::log')
log2      = builtin_func('std::log2')
rand      = builtin_func('rand', Int(32))
in_bounds = builtin_func('in_bounds', Int())
rand_uniform = builtin_func('rand_uniform', Float())
round     = builtin_func('std::round')
max       = builtin_func('std::max')
min       = builtin_func('std::min')
exit      = builtin_func('exit')
wall_time = builtin_func('wall_time', Float(64))
printf    = builtin_func('printf', Void())
gaussian_kernel = builtin_func('gaussian_kernel', Vector(Float(32)))
copy_nearest = builtin_func('copy_nearest')
check_valid_image = builtin_func('check_valid_image')

def gaussian_blur_functor(funcname):
    def f(input, output, *args, **kw):
        #sigma = as_expr(sigma)
        #sigma.add = False
        args = [as_expr(arg) for arg in args]
        for arg in args:
            arg.add = False
        real = input.type.scalar()
        atom = input.type.atom()
        array = input.type.codegen()
        channels = kw.get('channels', None)
        if channels is None:
            channels = input.type.channels_const(True)
        return CodeFragment('%s<%s, %s, %s, %d>(%s, %s, %s);' % (funcname, array, real, atom, channels,  input.codegen(), output.codegen(), ', '.join([x.codegen() for x in args])))
    return f

gaussian_blur_gaussian_pyramid = gaussian_blur_functor('gaussian_blur_gaussian_pyramid')
gaussian_blur_sat              = gaussian_blur_functor('gaussian_blur_sat')
box_blur                       = gaussian_blur_functor('box_blur')

def load_color_image(type, filename, extra_channels=0):
    target_array = type.codegen()
    source_array = copy.copy(type)
    source_array.vectorize = None
    source_array = source_array.codegen()
    source_type  = type.scalar()
    return CodeFragment('cast_array<%s, %s>(load_color_image<%s>("%s", %d))' % (source_array, target_array, source_type, filename, extra_channels), type, add=False)

debug_index = 0

def reset_debug_index():
    global debug_index
    debug_index = 0
    
def debug_image(I, suffix, channels=-1):
    global debug_index
    name = 'debug_%03d_%s' % (debug_index, suffix)
    save_color_image(I, name)
    check_valid_image(I, name, channels)
    debug_index += 1
    
def save_color_image(I, filename):
    orig_array = I.type.codegen()
    scalar_array = copy.copy(I.type)
    scalar_array.vectorize = None
    scalar_array = scalar_array.codegen()
    return CodeFragment('save_color_image(cast_array<%s, %s>(%s), "%s");' % (orig_array, scalar_array, I.codegen(), filename))
    
def gaussian_kernel_macro(sigma):
    "Gaussian IIR coefficients macro (compile time tuple for use with filter_iir). gaussian_kernel() does the same at run-time."
    # From Recursive implementation of the Gaussian filter, Young and van Vliet 1995
    sigma = _max(abs(sigma), 0.31)
    
    if sigma >= 2.5:
        q = 0.98711 * sigma - 0.96330
    else:
        q = 3.97156 - 4.14554 * math.sqrt(1 - 0.26891*sigma)
        q = _max(q, 0.0)
    
    b0 = 1.57825 + 2.44413 * q + 1.4281 * q**2 + 0.422205 * q**3
    b1 = 2.44413 * q + 2.85619 * q**2 + 1.26661 * q**3
    b2 = -(1.4281 * q**2 + 1.26661 * q**3)
    b3 = 0.422205 * q**3
    
    B = 1 - (b1 + b2 + b3) / b0
    
    return [B, b1/b0, b2/b0, b3/b0, 0.0]
    
def filter_iir_initial((a, b)):
    # Steady state output if infinite stream of 1s is fed into the filter
    n = 1000
    out_image = numpy.zeros(n)
    in_image = numpy.ones(n)
    for i in range(n):
        ans = 0.0
        for j in range(len(a)):
            ans += in_image[_max(i-j, 0)] * a[j]
        for j in range(len(b)):
            ans += out_image[_max(i-j-1, 0)] * b[j]
        out_image[i] = ans
    ans = out_image[-1]
    return ans

# --------------------------------------------------------------------
# IIR filter
# --------------------------------------------------------------------

def expand_iir_code(basename, atom, real, vectorize, vectorize0, channels, initial, dims):
    if dims == 4:
        forward_begin = """
        #pragma omp parallel for
        for (int z = 0; z < in.sizes[0]; z++) {
            for (int y = 0; y < in.sizes[1]; y++) {
                for (int x = 0; x < in.sizes[2]; x++) {
                    for (int c = 0; c < %(channels)s; c++) {
                        %(atom)s ans = a0*in.get_nearest(z, y, x, c);
        """ % locals()

        forward_begin_y = """
        #pragma omp parallel for
        for (int y = 0; y < in.sizes[1]; y++) {
            for (int z = 0; z < in.sizes[0]; z++) {
                for (int x = 0; x < in.sizes[2]; x++) {
                    for (int c = 0; c < %(channels)s; c++) {
                        %(atom)s ans = a0*in.get_nearest(z, y, x, c);
        """ % locals()

        reverse_begin = """
        #pragma omp parallel for
        for (int z = in.sizes[0]-1; z >= 0; z--) {
            for (int y = in.sizes[1]-1; y >= 0; y--) {
                for (int x = in.sizes[2]-1; x >= 0; x--) {
                    for (int c = 0; c < %(channels)s; c++) {
                        %(atom)s ans = a0*in.get_nearest(z, y, x, c);
        """ % locals()

        reverse_begin_y = """
        #pragma omp parallel for
        for (int y = in.sizes[1]-1; y >= 0; y--) {
            for (int z = in.sizes[0]-1; z >= 0; z--) {
                for (int x = in.sizes[2]-1; x >= 0; x--) {
                    for (int c = 0; c < %(channels)s; c++) {
                        %(atom)s ans = a0*in.get_nearest(z, y, x, c);
        """ % locals()
        
        end = """
                        in.get_nearest(z, y, x, c) = ans;
                    }
                }
            }
        }
        """
        
        return CodeFragment("""
    void %(basename)s(Array<%(atom)s, %(vectorize)s> &in, vector<float> coeffs) {
        double T0 = wall_time();
        ASSERT2(coeffs.size() == 5, "filter_iir() expected 5 coeffs");
        %(real)s a0(coeffs[0]);
        %(real)s b1(coeffs[1]);
        %(real)s b2(coeffs[2]);
        %(real)s b3(coeffs[3]);
        
        %(forward_begin)s
                        if (x-1 >= 0) { ans += b1*in.get_nearest(z, y, x-1, c); }
                        if (x-2 >= 0) { ans += b2*in.get_nearest(z, y, x-2, c); }
                        if (x-3 >= 0) { ans += b3*in.get_nearest(z, y, x-3, c); }
        %(end)s
        
        
        %(forward_begin)s
                        if (y-1 >= 0) { ans += b1*in.get_nearest(z, y-1, x, c); }
                        if (y-2 >= 0) { ans += b2*in.get_nearest(z, y-2, x, c); }
                        if (y-3 >= 0) { ans += b3*in.get_nearest(z, y-3, x, c); }
        %(end)s

        %(forward_begin_y)s
                        if (z-1 >= 0) { ans += b1*in.get_nearest(z-1, y, x, c); }
                        if (z-2 >= 0) { ans += b2*in.get_nearest(z-2, y, x, c); }
                        if (z-3 >= 0) { ans += b3*in.get_nearest(z-3, y, x, c); }
        %(end)s
    
        %(reverse_begin)s
                        if (x+1 < in.sizes[2]) { ans += b1*in.get_nearest(z, y, x+1, c); }
                        if (x+2 < in.sizes[2]) { ans += b2*in.get_nearest(z, y, x+2, c); }
                        if (x+3 < in.sizes[2]) { ans += b3*in.get_nearest(z, y, x+3, c); }
        %(end)s

        %(reverse_begin)s
                        if (y+1 < in.sizes[1]) { ans += b1*in.get_nearest(z, y+1, x, c); }
                        if (y+2 < in.sizes[1]) { ans += b2*in.get_nearest(z, y+2, x, c); }
                        if (y+3 < in.sizes[1]) { ans += b3*in.get_nearest(z, y+3, x, c); }
        %(end)s

        %(reverse_begin_y)s
                        if (z+1 < in.sizes[0]) { ans += b1*in.get_nearest(z+1, y, x, c); }
                        if (z+2 < in.sizes[0]) { ans += b2*in.get_nearest(z+2, y, x, c); }
                        if (z+3 < in.sizes[0]) { ans += b3*in.get_nearest(z+3, y, x, c); }
        %(end)s
        printf("iir_filter: %%f secs\\n", wall_time()-T0);
    }

        """ % locals(), header=True, once=True)
        
    ans = ''
    max_bn = 4
    
    begin_code = """
    void %(name)s(Array<%(atom)s, %(vectorize)s> &in, %(real)s a0, %(real)s b1, %(real)s b2, %(real)s b3, %(real)s b4) {
        %(begin_profile)s
        int h = in.height(), w = in.width();
        unsigned uh = h, uw = w;
        int ystart = 0, yend = h, ystep = 1;
        int xstart = 0, xend = w, xstep = 1;
        if (%(xdir)s < 0 || %(ydir)s < 0) {
            xstart = w-1; xend = -1; xstep = -1;
            ystart = h-1; yend = -1; ystep = -1;
        }
        if (in.dimensions() == 3) {
            """
    inner_code = """
            %(loops)s
                        for (int c = 0; c < %(channels)s; c++) {
                            %(atom)s ans = a0*in.get_nearest(y, x, c);
                            if (%(bn)d >= 1) { ans += b1*(IIR_IN_BOUNDS(%(xdir)s, %(ydir)s, 1) ? in.get_nearest(y-1*%(ydir)s, x-1*%(xdir)s, c): %(initial)s*in.get_clamp(y-1*%(ydir)s, x-1*%(xdir)s, c)); }
                            if (%(bn)d >= 2) { ans += b2*(IIR_IN_BOUNDS(%(xdir)s, %(ydir)s, 2) ? in.get_nearest(y-2*%(ydir)s, x-2*%(xdir)s, c): %(initial)s*in.get_clamp(y-2*%(ydir)s, x-2*%(xdir)s, c)); }
                            if (%(bn)d >= 3) { ans += b3*(IIR_IN_BOUNDS(%(xdir)s, %(ydir)s, 3) ? in.get_nearest(y-3*%(ydir)s, x-3*%(xdir)s, c): %(initial)s*in.get_clamp(y-3*%(ydir)s, x-3*%(xdir)s, c)); }
                            if (%(bn)d >= 4) { ans += b4*(IIR_IN_BOUNDS(%(xdir)s, %(ydir)s, 4) ? in.get_nearest(y-4*%(ydir)s, x-4*%(xdir)s, c): %(initial)s*in.get_clamp(y-4*%(ydir)s, x-4*%(xdir)s, c)); }
                            in.get_nearest(y, x, c) = ans;
                        }
                    }
                }
    """
    end_code = """
        } else {
            fprintf(stderr, "filter_recursive_separable dims: %%d\\n", in.dimensions());
            ASSERT2(false, "Unsupported filter_recursive_separable input shape");
        }
        %(end_profile)s
    }
    """

    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    names = ['right', 'left', 'down', 'up']    
    for i in range(4):
        (xdir, ydir) = dirs[i]
        cond = '<' if (xdir == 1 or ydir == 1) else '>'
        xdir = str(xdir)
        ydir = str(ydir)
        name = basename + '_' + names[i]

        loops = """
                for (int y = ystart; y %(cond)s yend; y += ystep) {
                    for (int x = xstart; x %(cond)s xend; x += xstep) {
        """ % locals()
        if int(xdir):
            loops = """
                #pragma omp parallel for""" + loops

        begin_profile = end_profile = ''
        if profile_time:
            begin_profile = 'double T0 = wall_time();'
            end_profile = 'printf("%(name)s: %%f secs\\n", wall_time()-T0);' % locals()
        all_code = begin_code%locals()
        for bn in range(max_bn,0,-1):
            mid = inner_code%locals()
            else_s = ''
            if bn != max_bn:
                else_s = 'else ' 
            all_code += """
            %(else_s)sif (b%(bn)d) {
                %(mid)s
            }"""%locals()
        all_code += """
            else {
                ASSERT2(false, "Unknown b coefficient pattern");
            }
            """
        all_code += end_code%locals()

        ans += all_code
        
    pretime = ''
    posttime = ''
    
    if get_profile_time():
        pretime = 'double T0 = wall_time();'
        posttime = '''printf("filter_iir: %f secs\\n", wall_time()-T0);'''
        
    code2 = """
    void %(basename)s(Array<%(atom)s, %(vectorize)s> &in, vector<float> coeffs) {
        %(pretime)s
        ASSERT2(coeffs.size() == 5, "filter_iir() expected 5 coeffs");
        %(real)s a0(coeffs[0]);
        %(real)s b1(coeffs[1]);
        %(real)s b2(coeffs[2]);
        %(real)s b3(coeffs[3]);
        %(real)s b4(coeffs[4]);
        %(basename)s_right(in, a0, b1, b2, b3, b4);
        %(basename)s_left (in, a0, b1, b2, b3, b4);
        %(basename)s_down (in, a0, b1, b2, b3, b4);
        %(basename)s_up   (in, a0, b1, b2, b3, b4);
        %(posttime)s
    }
    """
    ans += code2%locals()
    c = CodeFragment(ans, header=True, once=True)

def filter_iir(in_image, coeffs, initial=1.0, channels=None):
    array_type = in_image.type

    name = 'iir_filter_' + secure_hash(repr((array_type.codegen(), initial, channels)))
        
    atom = array_type.atom()
    real = array_type.scalar()
    vectorize0 = array_type.vectorize
    if vectorize0 is None:
        vectorize0 = 0
    vectorize = vectorize0
    if vectorize == 0:
        vectorize -= 1
        
    if channels is None:
        channels = array_type.channels_const(True)
    initial0 = initial
    initial = float_codegen(initial) #Const(initial).codegen() #'1.0f' #str(filter_iir_initial((a, b))) + 'f'

    fast_mode = in_image.type.dims == 3 and filter_iir_fast
    if fast_mode:
        iir_filter_func = builtin_func('iir_filter<%s, %d, %d>' % (atom, vectorize, channels))
        return iir_filter_func(in_image, coeffs, initial0)
    else:
        expand_iir_code(name, atom, real, vectorize, vectorize0, channels, initial, in_image.type.dims)
        #template<class T, int T_dims, int channels>
        #void iir_filter(Array<T, T_dims> &in, float a0, float b1, float b2, float b3)

    func = FuncRef(name)
    
    return func(in_image, coeffs)

def result_type(a, b):
    dims = _max(a.dims, b.dims)
    if a.dims != b.dims and a.dims != 0 and b.dims != 0:
        raise TypeError('op invalid on dimension %d and %d arrays (expected equal dims or scalar), %r, %r' % (a.dims, b.dims, a, b))
    
    if a.basetype == b.basetype:
        return Type(a.basetype, _max(a.bits, b.bits), dims)
    else:
        pair = (a.basetype, b.basetype)
        if pair in [('Float', 'Int'), ('Int', 'Float'), ('Float', 'UInt'), ('UInt', 'Float')]:
            return Type('Float', _max(a.bits, b.bits), dims)
        elif pair == ('UInt', 'Int') or pair == ('Int', 'UInt'):
            return Type('Int', _max(a.bits, b.bits), dims)
        else:
            raise TypeError('unknown how to combine types %r and %r' % (a, b))
        
# ------------------------------------------------------------------------------------
# Program transformations
# ------------------------------------------------------------------------------------
    
def program_lines(program, include_blocks=False):
    """
    List (node, parent) pairs in the program, one for each program line.
    """
    ans = []
    def f(node):
        if isinstance(node, (Block, Program)):
            for child in node.children:
                if not isinstance(child, Block) or include_blocks:
                    ans.append((child, node))
                f(child)
    f(program)
    return ans

def missing_loop_vars(node0):
    nodeL = []
    dimsL = set()
    def visit(node):
        if isinstance(node, Call):
            if node.children[0].type is not None:
                dims = node.children[0].type.dims
                nvars = len(node.children)-1
                if dims > nvars and not isinstance(node.children[0], Method):
    #                print
    #                print 'found missing', dims, nvars
    #                print node
    #                print
                    nodeL.append(node)
                    dimsL.update(set(range(nvars, dims)))
        for child in node.children:
            visit(child)
    for child in node0.children:
        visit(child)
    return (nodeL, sorted(dimsL))

def replace_node(program, node, replaceL):
    found = [False]
    def f(current):
        for (i, child) in enumerate(current.children):
            if child is node:
                current.children[i:i+1] = replaceL
                found[0] = True
                return
            f(child)
            if found[0]:
                return
    f(program)
    #print 'found:', found[0]
    if not found[0]:
        raise ValueError

class NotFoundError(Exception):
    pass

def get_foreach(program, img):
    ans = [None]
    def visit(node):
        if isinstance(node, ForEach):
            if node.arg_image() is img:
                ans[0] = node
        for child in node.children:
            visit(child)
    visit(program)
    if ans[0] is None:
        raise NotFoundError('ForEach over img not found in program:\n%r\n%r\n' % (program, img))
    return ans[0]

def set_no_add(program):
    def visit(node):
        node.add = False
        for child in node.children:
            visit(child)
    visit(program)
    
def transform_loop_missing(program):
    """
    Modify program to loop over missing variables.
    """
    set_no_add(program)
    visited = set()
    program = copy.deepcopy(program)
    #print '\n'.join(line[0].str() for line in program_lines(program))
    for (node, parent) in program_lines(program):
        #print '='*72
        #print node.str(), missing_loop_vars(node)
        #print '='*72
        #print
        (mnodeL, dims) = missing_loop_vars(node)
        for dim in dims:
            img = mnodeL[0].children[0]
            new_var = Var(add=False)
            size = Call(img.sizes(), (dim,), square_brackets=True)
            if img.type is not None:
                try:
                    size = int(img.type.get_size('', dim))
                except ValueError:
                    pass
            
            if dim == img.channels_const()-1:           # Loop only over foreach.channels number of channels
                try:
                    foreach = get_foreach(program, img)
                    size = foreach.channels
                except NotFoundError:
                    pass
            
            new_node = For(new_var, 0, size, add=False)
            new_node.children.append(node)
            replace_node(program, node, [new_var, new_node])
            for mnode in mnodeL:
#                print 'mnode', mnode
                assert isinstance(mnode, Call)
                if id(mnode) not in visited:
                    visited.add(id(mnode))
                    mnode.children.append(new_var)          # Call new variables
    set_no_add(program)
    return program
        #if missing_vars(node):

def transform_channels(program):
    # Incomplete
    return program
    program = copy.deepcopy(program)
    
    visited = set()
    def visit(node):
        if id(node) not in visited:
            visited.add(id(node))
            if isinstance(node, Call) and len(node.children) >= 1 and isinstance(node.children[0], Method) and node.children[0].methodname == 'channels':
                print '**** Found call to channels:'
                print node
                Itype = node.children[0].children[0].type
                if len(Itype.sizes) >= 3 and Itype.sizes[2] is not None:
                    fixed_size = Itype.sizes[2]
                    print 'Fixed size %d' % fixed_size
                sys.exit(0)
            for child in node.children:
                visit(child)
    visit(program)
    
    return program
    
def makenames(__f, caller_num=1):
    source = inspect.getsource(__f)
    while len(source.split('\n')) and source.split('\n')[0].startswith('@'):
        source = '\n'.join(source.split('\n')[1:])
    source = source.replace('@makenames', '')
    for varclass in ['Var', 'Argument']:
        pattern = '(.*?)' + re.escape('=') + '[ \t]*' + re.escape('%s('%varclass) + '.*' + re.escape(")") + '[ \t]*'
        #print repr(pattern)
        def replace_var(x):
            if 'name=' in x.group(0):
                return x.group(0)
            return x.group(0).rstrip()[:-1] + '%sname="%s")' % ('' if x.group(0).replace(' ', '').replace('\t', '').endswith('()') else ',', x.group(1).strip())
        source = re.sub(pattern, replace_var, source)
        
    def re_func(x):
        if 'name=' not in x.group(0):
            return x.group(1) + '%s name="%s") as '%('' if x.group(1).endswith('(') else ',', x.group(2)) + x.group(2) + ':'
        return x.group(0)
        
    source = re.sub('(' + re.escape('with Function(') + '.*?)' + re.escape(') as ') + '(.*?)' + re.escape(':'), re_func, source)
    
    source = re.sub('(' + re.escape('with ForEach(') + '.*?)' + re.escape(') as ') + '(.*?)' + re.escape(':'), re_func, source)

    source = re.sub('(' + re.escape('with For(') + '.*?)' + re.escape(') as ') + '(.*?)' + re.escape(':'), re_func, source)
    
    if debug:
        print '-'*72
        print 'Debug info: makenames() resulting Python code:'
        print '-'*72
        print source
    #sys.exit(1)
    caller_globals = inspect.stack()[caller_num][0].f_globals 
    
    exec source in caller_globals, locals()
    return eval(__f.__name__)

# ------------------------------------------------------------------------------------
# Template functions
# ------------------------------------------------------------------------------------

def maketemplate(f0, names=True):
    """Given a Python function over types ('template') returning a Function instance, memoize the Python function."""
    #print 'maketemplate:', f0.func_name
    #print inspect.getsource(f0)
    f = makenames(f0, 2) if names else f0
    #print 'done makenames'
    
    cache = {}
    def g(*args, **kw):
        s = repr((args, kw))
        if s in cache:
            return cache[s]
        ans = f(*args, **kw)
        name = f0.func_name + '_' + secure_hash(s)
        ans.function.name = name
        ans.name = name
#        print '*'*72
#        print ans.function
#        print '*'*72
#        sys.exit(1)
        block_stack[0].header_funcs.append(ans.function) #[ans.function] + block_stack[0].children
        cache[s] = ans
        return ans
    
    return g

@maketemplate
def default_importance(tIn, tOut, kw):
    """Get importance sampling function for given array types tIn, tOut."""
    with Function(add=False) as f:
        input = Argument(tIn)
        output = Argument(tOut)
        sigma_frac = Argument(Float(64))
        output.resize(input.sizes())
        
        if get_profile_time(kw):
            T0 = Var(wall_time())
        
        sigma = Var(sigma_frac*input.height())
        K = Var(gaussian_kernel(sigma))
        
        (x, y, c) = (Var(), Var(), Var())
        if synthetic_importance:
            with ForEach((y, x, c), output, prefix='__default_importance_synthetic_importance_'):
                output[y,x,c] = 0.05+x*0.95/output.width()
        else:
            if importance_method == 'gaussian':
                if optimize_channels and not debug_save:
                    with ForEach((y, x), output, prefix='__default_importance_copy0_'):
                        output[y,x,0] = input[y,x,0]
                else:
                    with ForEach((y, x, c), output, prefix='__default_importance_copy_'):
                        output[y,x,c] = input[y,x,0]
                filter_iir(output, K, channels=1 if optimize_channels else None)
            elif importance_method == 'box':
                n_sigma = Var(Int(), sigma*2.8)     # Magic constant from maximizing box/Gaussian dot product
                box_blur(input, output, n_sigma, channels=1)
            else:
                raise ValueError('default_importance: unknown importance_method %s' % importance_method)
            if optimize_channels:
                with ForEach((y, x), output, prefix='__default_importance_abs0_'):
                    output[y,x,0] = abs(output[y,x,0]-input[y,x,0])
            else:
                with ForEach((y, x, c), output, prefix='__default_importance_abs_'):
                    output[y,x,c] = abs(output[y,x,c]-input[y,x,0])
            if importance_method == 'gaussian':
                filter_iir(output, K, channels=1 if optimize_channels else None)
            elif importance_method == 'box':
                box_blur(output, output, n_sigma, channels=1)
            else:
                raise ValueError('default_importance: unknown importance_method %s' % importance_method)
            #gaussian_blur_sat(output, output, sigma, 1, channels=1)

            if min_density:
                max_val = Var(Float(), 0.0)
                with ForEach((y, x), output, prefix='__default_importance_min_density_get_max_'):
                    with If(output[y, x, 0] > max_val):
                        Assign(max_val, output[y, x, 0])
                with ForEach((y, x), output, step=(min_density_spacing, min_density_spacing), prefix='__default_importance_min_density_'):
                    output[y,x,0] = max_val
        if get_profile_time(kw):
            printf('default_importance: %f sec\n', wall_time()-T0)

    return f

@maketemplate
def image_importance(tIn, tOut, filename=None):
    """Get importance sampling function for given array types tIn, tOut."""
    with Function(add=False) as f:
        input = Argument(tIn)
        output = Argument(tOut)
        sigma_frac = Argument(Float(64))
        Assign(output, load_color_image(tOut, filename))
        printf('importance sampling image: %dx%dx%d, max: %f\n', output.width(), output.height(), output.channels(), output.max())
    return f

@maketemplate
def grid_importance(tIn, tOut, factor=2):
    """Grid importance sampling function for array types tIn, tOut."""
    with Function(add=False) as f:
        refArray = Argument(tIn)

#        Itype = copy.deepcopy(refArray.type)
#        Itype.basetype = 'Float'
#        Itype.bits = 32

        Isample = Argument(tOut)
        sigma = Argument(Float())
        
        y = Var()
        x = Var()
        c = Var()
        Isample.resize(refArray.sizes())
        with For(y, 0, Isample.height()):
            with For(x, 0, Isample.width()):
                if not optimize_channels:
                    with For(c, 0, Isample.channels()):
                        Isample[y,x,c] = And(x%factor == 0, y%factor == 0)
                else:
                    Isample[y,x,0] = And(x%factor == 0, y%factor == 0)

    return f
    
@maketemplate
def rescale_dither(t, kw):
    """Rescale input image (fed to dithering) in place so that the pixel sum is equal to 'frac'*npixels."""
    with Function(add=False) as f:
        I = Argument(t)
        frac = Argument(Float(32))
        
        if get_profile_time(kw):
            T0 = Var(wall_time())
        
        with If(frac > 1):
            Assign(frac, 1.0)
        with ElseIf(frac < 0):
            Assign(frac, 0.0)
        
        x = Var()
        y = Var()
        i = Var()
        scale = Var(0.0)

        if rescale_fast:
            # Fast implementation based on histogram (see importance_sampling_notes_rescale.docx)
            min_val = Var(t.scalar_type(), I[0,0,0])
            max_val = Var(t.scalar_type(), I[0,0,0])
            
            with ForEach((y, x), I, parallel=True, parallel_options='reduction(max:max_val) reduction(min:min_val)', prefix='__rescale_dither_minmax_'):
                c = Var(t.scalar_type(), I[y,x,0])
                with If(c < min_val):
                    Assign(min_val, c)
                with ElseIf(c > max_val):
                    Assign(max_val, c)

            m = Var(Int(), 1000)                    # Bins
            n = Var(Int(), I.width()*I.height())    # Pixels
            
            h = Var(Array(Int(), 1, sizes=[m]), [m])     # Histogram count
            h.clear()
            
            color_to_bin_scale = Var(Float(), (m-0.01)/(max_val-min_val))
            #with ForEach((y, x), I, parallel=False, prefix='__rescale_dither_histo_count_'):
            #    c = Var(t.scalar_type(), I[y,x,0])
            #    idx = Var(Int(), (c-min_val)*color_to_bin_scale)
            #    Assign(h[idx], h[idx]+1)
            
            # Parallel histogram reduction
            if get_profile_time(kw):
                CodeFragment(r"""
                double T0_histo = wall_time();
                """)
            CodeFragment(r"""
            #pragma omp parallel
            {
                int *h_private = new int[m];
                for (int j = 0; j < m; j++) { h_private[j] = 0; }
                #pragma omp for nowait
                for (int yp = 0; yp < I.height(); yp++) {
                    auto row = &I.get_nearest(yp, 0, 0);
                    for (int xp = 0; xp < I.width(); xp++) {
                        auto c = *(row + xp*I.stride[1]);
                        int idx = int((c-min_val)*color_to_bin_scale);
                        h_private[idx] += 1;
                    }
                }
                #pragma omp critical
                {
                    for (int j = 0; j < m; j++) {
                        h.get_nearest(j) += h_private[j];
                    }
                }
                delete[] h_private;
            }
            """)
            if get_profile_time(kw):
                CodeFragment(r"""
                printf("rescale_dither histo time: %f\n", wall_time()-T0_histo);
                """)
            
            k = Var()
            h_partial = Var(Float(), 0.0)
            hx_partial = Var(Float(), 0.0)
            
            eps = 1e-8
            
            with For(k, 0, m):
                h_val = Var(h[k])
                
                x_val      = Var(Float(), min_val + (k+  0.5) * (max_val-min_val)/m)
                x_val_next = Var(Float(), min_val + (k+1+0.5) * (max_val-min_val)/m)
                
                Assign(h_partial, h_partial + h_val)
                Assign(hx_partial, hx_partial + h_val*x_val)
                
                s = Var(Float(), 0.0)
                with If(hx_partial != 0.0):
                    Assign(s, (h_partial - n*(1-frac)) / hx_partial)
                    s_max = Var(Float(), 1.0/x_val)
                    s_min = Var(Float(), 0.0)
                    with If(k+1 < m):
                        Assign(s_min, 1.0/x_val_next)
                    
                    with If(And(s <= s_max*(1+eps), s >= s_min/(1+eps))):
                        Assign(scale, s)
                        Break()
        else:
            # Slow implementation based on Newton's method
            T = Var(frac*I.width()*I.height())
            tol = Var(1e-4)
            
            with For(i, 0, 100):
                fI = Var(-T)
                fp = Var(Float(32), 0.0)
                with ForEach((y, x), I, parallel_options='reduction(+:fI) reduction(+:fp)', prefix='__rescale_dither_newton_'):
                    c = Var(t.scalar_type(), I[y,x,0])
                    with If(c*scale <= 1):
                        fI += c*scale
                        fp += c
                    with Else():
                        fI += 1
                delta = Var(fI/fp)
                with If(abs(delta)/(1+abs(scale)) <= tol):
                    Break()
    #            printf('rescale_dither: i=%d, fI=%f, fp=%f, delta=%f, scale=%f, T=%f\n', i, fI, fp, delta, scale, T)
                scale -= delta            # Newton-Raphson step
    #        printf('rescale_dither: stopped after %d iterations, scale=%f\n', i, scale)

        if get_profile_time(kw):
            CodeFragment(r"""printf("rescale_dither applying scale=%f\n", scale); fflush(stdout);""")

        channel = Var()
        if optimize_channels:
            #with ForEach((y, x), I, parallel=True, prefix='__rescale_dither_apply_'):
            #    I[y,x,0] = min(I[y,x,0]*scale, 1.0)
            CodeFragment(r"""
            #pragma omp parallel for private(channel,x,y)
            for (int y = 0; y < I.height(); y++) {
                auto row = &I.get_nearest(y, 0, 0);
                for (int x = 0; x < I.width(); x++) {
                    auto p = &row[x*I.stride[1]];
                    *p = MIN((*p)*scale, 1.0);
                }
            }
            """)
        else:
            with ForEach((y, x, channel), I, parallel=True, prefix='__rescale_dither_apply_'):
                I[y,x,channel] = min(I[y,x,channel]*scale, 1.0)

        
        if get_profile_time(kw):
            printf('rescale_dither: %f secs, %d iterations, scale=%f\n', wall_time()-T0, i+1, scale)
    return f
    
@maketemplate
def dither_floyd(t, kw):
    """Run Floyd-Steinberg dithering in place, quantizing to zero or one."""
    
    with Function(add=False) as f:
        I = Argument(t)
        if get_profile_time(kw):
            T0 = Var(wall_time())
        
        x = Var()
        y = Var()
        c = Var()
        error = Var(0.0)
        with For(y, 0, I.height(), parallel=False):
            dx_current = Var(Select(y % 2 == 0, 1, -1))
            for dx in [-1, 1]:
                with If(dx == dx_current):
                    (xstart, xend, xstep) = (0, I.width(), 1)
                    if dx < 0:
                        (xstart, xend, xstep) = (I.width()-1, -1, -1)
                    with For(x, xstart, xend, xstep, parallel=False):
                        new_color = Var(Float(32), I[y,x,0] >= 0.5)
                        error = Var(I[y,x,0] - new_color)
                        I[y,x,0] = new_color
                        with If(in_bounds(x+dx, I.width())):
                            I[y,x+dx,0] += (7.0/16.0) * error
                        with If(y+1 < I.height()):
                            with If(in_bounds(x-dx, I.width())):
                                I[y+1,x-dx,0] += (3.0/16.0) * error
                            I[y+1,x,0] += (5.0/16.0) * error
                            with If(in_bounds(x+dx, I.width())):
                                I[y+1,x+dx,0] += (1.0/16.0) * error

            with For(c, 1, I.channels_const()):
                I[y,x,c] = I[y,x,0]
        
        if get_profile_time(kw):
            printf('dither_floyd: %f secs\n', wall_time()-T0)
    return f


@maketemplate
def dither_ost(t, kw):
    """Run Ostromoukhov dithering in place, quantizing to zero or one."""
    with Function(add=False) as f:
        I = Argument(t)
        if get_profile_time(kw):
            T0 = Var(wall_time())

        coeffL = [
        [13, 0, 5],
        [13, 0, 5],
        [21, 0, 10],
        [7, 0, 4],
        [8, 0, 5],
        [47, 3, 28],
        [23, 3, 13],
        [15, 3, 8],
        [22, 6, 11],
        [43, 15, 20],
        [7, 3, 3],
        [501, 224, 211],
        [249, 116, 103],
        [165, 80, 67],
        [123, 62, 49],
        [489, 256, 191],
        [81, 44, 31],
        [483, 272, 181],
        [60, 35, 22],
        [53, 32, 19],
        [237, 148, 83],
        [471, 304, 161],
        [3, 2, 1],
        [481, 314, 185],
        [354, 226, 155],
        [1389,866, 685],
        [227, 138, 125],
        [267, 158, 163],
        [327, 188, 220],
        [61, 34, 45],
        [627, 338, 505],
        [1227,638, 1075],
        [20, 10, 19],
        [1937,1000,1767],
        [977, 520, 855],
        [657, 360, 551],
        [71, 40, 57],
        [2005,1160,1539],
        [337, 200, 247],
        [2039,1240,1425],
        [257, 160, 171],
        [691, 440, 437],
        [1045,680, 627],
        [301, 200, 171],
        [177, 120, 95],
        [2141,1480,1083],
        [1079,760, 513],
        [725, 520, 323],
        [137, 100, 57],
        [2209,1640,855],
        [53, 40, 19],
        [2243,1720,741],
        [565, 440, 171],
        [759, 600, 209],
        [1147,920, 285],
        [2311,1880,513],
        [97, 80, 19],
        [335, 280, 57],
        [1181,1000,171],
        [793, 680, 95],
        [599, 520, 57],
        [2413,2120,171],
        [405, 360, 19],
        [2447,2200,57],
        [11, 10, 0],
        [158, 151, 3],
        [178, 179, 7],
        [1030,1091,63],
        [248, 277, 21],
        [318, 375, 35],
        [458, 571, 63],
        [878, 1159,147],
        [5, 7, 1],
        [172, 181, 37],
        [97, 76, 22],
        [72, 41, 17],
        [119, 47, 29],
        [4, 1, 1],
        [4, 1, 1],
        [4, 1, 1],
        [4, 1, 1],
        [4, 1, 1],
        [4, 1, 1],
        [4, 1, 1],
        [4, 1, 1],
        [4, 1, 1],
        [65, 18, 17],
        [95, 29, 26],
        [185, 62, 53],
        [30, 11, 9],
        [35, 14, 11],
        [85, 37, 28],
        [55, 26, 19],
        [80, 41, 29],
        [155, 86, 59],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [5, 3, 2],
        [305, 176, 119],
        [155, 86, 59],
        [105, 56, 39],
        [80, 41, 29],
        [65, 32, 23],
        [55, 26, 19],
        [335, 152, 113],
        [85, 37, 28],
        [115, 48, 37],
        [35, 14, 11],
        [355, 136, 109],
        [30, 11, 9],
        [365, 128, 107],
        [185, 62, 53],
        [25, 8, 7],
        [95, 29, 26],
        [385, 112, 103],
        [65, 18, 17],
        [395, 104, 101],
        [4, 1, 1]]
        
        coeffs = numpy.array(coeffL, float)
        coeff_sum = numpy.sum(coeffs, 1)
        d10_py = coeffs[:,0] / coeff_sum
        d11_py = coeffs[:,1] / coeff_sum
        d01_py = coeffs[:,2] / coeff_sum

        DitherArray = Array(Float(), 1, sizes=[128])
        d10 = Var(DitherArray)
        d11 = Var(DitherArray)
        d01 = Var(DitherArray)
        
        CodeFragment('static int first_time = 1; if (first_time) { first_time = 0;')
        d10.resize([128])
        d11.resize([128])
        d01.resize([128])
        for i in range(128):
            d10[i] = d10_py[i]
            d11[i] = d11_py[i]
            d01[i] = d01_py[i]
        CodeFragment('}')
        
        x = Var()
        y = Var()
        c = Var()
        error = Var(0.0)
        with For(y, 0, I.height(), parallel=False):
            dx_current = Var(Select(y % 2 == 0, 1, -1))
            for dx in [-1, 1]:
                with If(dx == dx_current):
                    (xstart, xend, xstep) = (0, I.width(), 1)
                    if dx < 0:
                        (xstart, xend, xstep) = (I.width()-1, -1, -1)
                    with For(x, xstart, xend, xstep, parallel=False):
                        quantize_c = Var(Int(), I[y,x,0]*255.99)
                        with If(Not(in_bounds(quantize_c, 256))):
                            Assign(quantize_c, 0)
                        with ElseIf(quantize_c >= 128):
                            Assign(quantize_c, 255-quantize_c)
                            
                        new_color = Var(Float(32), I[y,x,0] >= 0.5)
                        error = Var(I[y,x,0] - new_color)
                        I[y,x,0] = new_color
                        with If(in_bounds(x+dx, I.width())):
                            I[y,x+dx,0] += d10[quantize_c] * error
                        with If(y+1 < I.height()):
                            with If(in_bounds(x-dx, I.width())):
                                I[y+1,x-dx,0] += d11[quantize_c] * error
                            I[y+1,x,0] += d01[quantize_c] * error
            
                        with For(c, 1, I.channels_const()):
                            I[y,x,c] = I[y,x,0]
        
        if get_profile_time(kw):
            printf('dither_ostromoukhov: %f secs\n', wall_time()-T0)
    return f

@maketemplate
def filter_1d(ImageType):
    """Image filter (convolution) in a single 1D direction, in place."""
    with Function(add=False) as f:
        I = Argument(ImageType)
        dx = Argument(Int())
        dy = Argument(Int())
        weight = Argument(Array(ImageType.scalar_type(), 1))
        
        I0 = Var(I)
        size = Var(weight.size())

        x = Var()
        y = Var()
        with ForEach((y, x), I, prefix='__filter_1d_'):
            I[y, x] = 0.0
            i = Var(Int())
            with For(i, -(size/2), size/2+1):
                xp = Var(x + dx*i)
                yp = Var(y + dy*i)
                with If(xp < 0):
                    Assign(xp, 0)
                with ElseIf(xp >= I.width()):
                    Assign(xp, I.width()-1)
                with If(yp < 0):
                    Assign(yp, 0)
                with ElseIf(yp >= I.height()):
                    Assign(yp, I.height()-1)
                I[y, x] += I0[yp, xp] * weight[size/2-i]
    return f

@maketemplate
def filter_separable(ImageType):
    """Separable image filter (convolution), in place. Assumes same weight in both x and y directions."""
    with Function(add=False) as f:
        I = Argument(ImageType)
        weight = Argument(Array(ImageType.scalar_type(), 1))
        filter_1d(ImageType)(I, 1, 0, weight)
        filter_1d(ImageType)(I, 0, 1, weight)
    return f
    
# ------------------------------------------------------------------------------------
# Test suite
# ------------------------------------------------------------------------------------

def get_image_types(is_vectorize):
    Real = Float(32)
    if is_vectorize:
        Image4 = Array(Real, 3, sizes=(None, None, 4), vectorize=2)
        Image = Image4 
    else:
        Image = Array(Real, 3, sizes=(None, None, 3))
    return (Real, Image)
    
@makenames
def test_blur2(is_vectorize=False):
    (Real, Image) = get_image_types(is_vectorize)
    with Program() as program:
        with Function() as main_func:
            input = Argument(Image)
            output = Argument(Image)
            output.resize(input.sizes())
            temp = Var(Image)
            temp.resize(input.sizes())
            
            x = Var()
            y = Var()
            
            with ForEach((y, x), temp) as loop_temp:
                with If(And(x-1 >= 0, x+1 < input.width())):
                    temp[y, x] = (input[y, x-1] + 2*input[y, x] + input[y, x+1])/4
                with Else():
                    temp[y, x] = 0.0
        
            with ForEach((y, x), output) as loop_output:
                with If(And(y-1 >= 0, y+1 < temp.height())):
                    output[y, x] = (temp[y-1, x] + 2*temp[y, x] + temp[y+1, x])/4
                with Else():
                    output[y, x] = 0.0
            
            loop_temp.sample_grid((1,2))
            loop_output.sample_grid((2,2))
#            loop_output.sample_grid((2,1))
            
    assert len(block_stack) == 0
    return program

@makenames
def test_blur1(is_vectorize=False):
    (Real, Image) = get_image_types(is_vectorize)
    sigma = 2.0
    h = 4
    dxL = dyL = range(-h, h+1)
    A = numpy.array([[numpy.exp(-(dx*dx+dy*dy)/(2.0*sigma**2)) for dx in dxL] for dy in dyL])
    A = A / numpy.sum(A.flatten())
    
    with Program() as program:
        with Function() as main_func:
            input = Argument(Image)
            output = Argument(Image)
            output.resize(input.sizes())
            
            x = Var()
            y = Var()
            
            with ForEach((y, x), output) as loop_output:
                with If(And(x-h >= 0, x+h < input.width(), y-h >= 0, y+h < input.height())):
                    output[y, x] = sum([A[dy+4][dx+4]*input[y+dy, x+dx] for dy in dyL for dx in dxL])
                with Else():
                    output[y, x] = 0.0
            
            loop_output.sample_grid((2,2))
            
    assert len(block_stack) == 0
    return program

@makenames
def test_program2(is_vectorize=False):
    (Real, Image) = get_image_types(is_vectorize)

    with Program() as program:
        with Function() as main_func:
            input = Argument(Image)
            output = Argument(Image)
            output.resize(input.sizes())
            
            i = Var()
            output[1,2] = 0.0
            with For(i, 1, 1000000, 1, output[1, 2, 0]) as for_loop:
                output[1,2] += input[0,0]*1.0/i**2
            
            x = Var()
            y = Var()
            x += y
            printf('Value: %f\n', output[1,2])

    for_loop.sample_contiguous(0.9)
    for_loop.sample_step(2)
    for_loop.sample_random(0.9)
    for_loop.early_terminate(0.0001)
    
    assert len(block_stack) == 0
    return program

@makenames
def test_program3(is_vectorize=False):
    (Real, Image) = get_image_types(is_vectorize)
    with Program() as program:
        with Function() as main_func:
            input = Argument(Image)
            output = Argument(Image)
            
            output.resize(input.sizes())
            
            filter_iir(input, gaussian_kernel(8.0))
            Assign(output, input)
            
    assert len(block_stack) == 0
    return program

@makenames
def test_program4(is_vectorize=False):
    (Real, Image) = get_image_types(is_vectorize)
    with Program() as program:
        with Function() as main_func:
            input = Argument(Image)
            output = Argument(Image)
            
            T0 = Var(wall_time())
            default_importance(Image)(input, output, 1.0/64.0)
#            printf('importance initial map:   %dx%d, mean: %f\n', output.width(), output.height(), output.sum()/(output.width()*output.height()*output.channels()))
            T1 = Var(wall_time())
            x = Var()
            y = Var()
            rescale_dither(Image)(output, 0.5)
            T2 = Var(wall_time())
#            printf('importance after rescale: %dx%d, mean: %f\n', output.width(), output.height(), output.sum()/(output.width()*output.height()*output.channels()))
            floyd(Image, kw)(output)
            T3 = Var(wall_time())
#            printf('importance after dither:  %dx%d, mean: %f\n', output.width(), output.height(), output.sum()/(output.width()*output.height()*output.channels()))
            printf('importance: %f, rescale: %f, floyd: %f\n', T1-T0, T2-T1, T3-T2)
    return program

@makenames
def test_program5(is_vectorize=False):
    (Real, Image) = get_image_types(is_vectorize)
    with Program() as program:
        with Function() as main_func:
            input = Argument(Image)
            output = Argument(Image)
            output.resize(input.sizes())

            x = Var()
            y = Var()
            
            with ForEach((y,x), output, input) as loop:
                output[y,x] = rand_uniform()
    
#    loop.sample_grid((32, 32))
    loop.sample_importance()
    loop.reconstruct_store(kernel=gaussian_kernel_macro(32.0/2.0))
    loop.importance_func = grid_importance
    loop.rescale = False
    return program

@makenames
def test_program6(is_vectorize=False):
    is_vectorize = False
    (Real, Image) = get_image_types(is_vectorize)
    with Program() as program:
        with Function() as main_func:
            input = Argument(Image)
            output = Argument(Image)
            output.resize(input.sizes())

            gaussian_blur_gaussian_pyramid(input, output, 8.0)    

    return program

@makenames
def test_program7(is_vectorize=False):
    is_vectorize = False
    (Real, Image) = get_image_types(is_vectorize)
    with Program() as program:
        with Function() as main_func:
            input = Argument(Image)
            output = Argument(Image)
            output.resize(input.sizes())
            sigma = Var(Image, input.sizes())
            x = Var()
            y = Var()
            with ForEach((y, x), sigma, parallel=True):
                sigma[y,x,0] = 0.0+(16.0)*x/input.width()
                
            gaussian_blur_sat(input, output, sigma)    

    return program
    
def print_program(program, msg='', kw={}):
    print '-'*80
    print 'Program%s' % msg
    print '-'*80
    print
    print program
    print
    print '-'*80
    print 'Codegen%s' % msg
    print '-'*80
    print
    print program.codegen(**kw)
    print

def time_filename(out_filename):
    return out_filename + '-time.txt'
    
def read_time(out_filename):
    ans = 0
    count = 0
    first = True
    for line in open(time_filename(out_filename), 'rt').read().split('\n'):
        if line.startswith('Total time:'):
            if not first:
                ans += float(line.split()[-1])
                count += 1
            first = False
    if count == 0:
        raise ValueError('Could not parse %s (did program segfault?)' % time_filename(out_filename))
    ans /= count
    return ans

def get_containing_folder(path):
    head, tail = ntpath.split(path)
    return head

def copyfile(a, b):
    if not os.path.exists(b) or not os.path.samefile(a, b):
        b_containing_folder = get_containing_folder(b)
        if not os.path.exists(b_containing_folder):
            os.makedirs(b_containing_folder)
        shutil.copy(a, b)

def compile_run_filenames(kw):
    filename = kw.get('filename', None)
    if filename is None:
        filename = kw.get('args', 'out.png').split()[-1]
    suffix = '.png'
    if os.path.splitext(filename)[1]:
        (filename, suffix) = os.path.splitext(filename)
    args = kw.get('args', 'lighthouse_small.png %s%s' % (filename, suffix))
    filename0 = kw.get('file_name_prefix', str(os.getpid()))
    return (filename, args, filename0)

def run_only(program, kw={}):
    (filename, args, filename0) = compile_run_filenames(kw)
    system('"%s" %s 2>&1 | tee %s' % (os.path.abspath(filename0), args, time_filename(filename0)))
#    copyfile(filename0, filename)
    copyfile(time_filename(filename0), time_filename(filename))
    if get_profile_time(kw):
        print
    return {'time': read_time(filename)}
    
def compile_and_run_on_several_images(approx_file, input_directory, output_directory, kw0, program):
    return_value = {}
    have_compiled = False
    
    prefix = re.sub('[^0-9a-zA-Z]+', '',('out_'+''.join(map(str,[os.getpid()])))+''.join(get_containing_folder(output_directory)) )
    for i,e in enumerate([ f for f in os.listdir(input_directory) if os.path.isfile(os.path.join(input_directory,f)) and f[-4:]=='.png' ]):
        input_file_locations = os.path.join(input_directory, e)
        output_file_location = os.path.join(output_directory,e[:-4]+'-out.png')
        program_arguments = input_file_locations+' '+output_file_location 
        kw = dict(args=program_arguments, file_name_prefix=prefix,**kw0)
        if (have_compiled):
            ans = run_only(program, kw)
            return_value[ kw['args'].split()[0]+'_time' ] = ans['time']
        else:
            ans = compile_and_run(program, kw)
            return_value = {}
            return_value[ kw['args'].split()[0]+'_time' ] = ans['time']
            have_compiled = True
            
#    os.system('rm '+os.getcwd()+'/'+prefix)
#    os.system('rm '+os.getcwd()+'/'+prefix+'-time.txt')
#    os.system('rm '+os.getcwd()+'/'+prefix+'.cpp')
    return return_value
    
def compile_and_run(program, kw={}):
    """
    Compile and run given program.
    
    Arguments in kw dict:
      - filename: str     Prefix for all output files
      - do_print: bool    Print program output
      - args:     str     Command-line arguments for output program
    """
    (filename, args, filename0) = compile_run_filenames(kw)

    do_print = kw.get('do_print', 0)
    if not kw['is_vectorize']:
        if do_print:
            print_program(program, ' (Before loop transform)', kw)
        program = transform_loop_missing(program)
    #program = transform_channels(program)

    if do_print:    
        print_program(program, '', kw)
    
    program.compile_to_file(filename0, **kw)
#    copyfile(filename0 + '.cpp', filename + '.cpp')
    return_value = run_only(program, kw)
    return return_value
    
def run_test(program_name, debug=False, vectorize=True, parallel=False):
    kw = dict(parallel=parallel, is_vectorize=vectorize, debug=debug, do_print=True)

    func = eval('test_%s' % program_name)
    program = func(is_vectorize=kw['is_vectorize'])
    
    info = compile_and_run(program, kw)
    print 'Minimum total time:', info['time']

def parse_app_commandline(command_line_args_list):
    approx_file = ''
    if (len(command_line_args_list) > 1):
        if (command_line_args_list[1][-7:]=='.approx'):
            approx_file = command_line_args_list[1]
    kw0 = {}
    if '-profile' in command_line_args_list:
        kw0 = {'profile_time': True, 'num_iters': 1}
    kw = {'approx_file': approx_file, 'kw0': kw0}
    
    print 
    if len(approx_file) > 0:
        print "Applying Approximations from file: "+approx_file
    
    if '-input_directory' in command_line_args_list:
        kw['input_directory'] = command_line_args_list[command_line_args_list.index('-input_directory')+1]
        print "Input Directory: "+kw['input_directory']
    if '-output_directory' in command_line_args_list:
        kw['output_directory'] = command_line_args_list[command_line_args_list.index('-output_directory')+1]
        print "Output Directory: "+kw['input_directory']
    print 
        
    return kw
    
def apply_approximations_from_file(globals_var, locals_var, approximation_file_name, ignore_errors=False):
    invalid_names = set()
    if (approximation_file_name != ""):
        approx_file = open(os.path.abspath(approximation_file_name), 'r')
        for command in approx_file:
            try:
                exec command in locals_var, globals_var     # Intentionally backwards so globals can be written to
            except NameError:
                if not ignore_errors:
                    raise
                name = command.split('.')[0]
                invalid_names.add(name)
            except:
                if ignore_errors:
                    print '-'*72
                    print 'Warning: could not apply line %s' % command.strip()
                    traceback.print_exc()
                    print '-'*72
                else:
                    raise
        approx_file.close()
    return invalid_names
    
def usage():
    print 'python approx.py [blur1|blur2|program2|program3] [-debug 0] [-vectorize 1] [-parallel 0] -- Test given program'
    sys.exit(1)

def main():
    (args, kw) = parse_args.parse_args(['debug', 'vectorize', 'parallel'], usage)
    
    if len(args) == 0:
        usage()
    
    run_test(args[0], debug=int(kw.get('debug', 0)),
                      vectorize=int(kw.get('vectorize', 1)),
                      parallel=int(kw.get('parallel', 0)))
    
if __name__ == '__main__':
    main()
    
